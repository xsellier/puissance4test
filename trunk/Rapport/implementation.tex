% -*- mode: latex; coding: latin-1-unix -*- %

\section{Implementation}

\subsection{DataStructure}
\subsubsection{Matrice}
\begin{verbatim}
   private int[][] matrix;
   private int height;
   private int width;
\end{verbatim}
Nous avons choisi d'utiliser une matrice pour modéliser une grille de
Puissance 4. Ce sera un tableau d'entiers. Afin de faire moins de
calculs, nous avons choisi de stocker la hauteur ainsi que la largeur
de la matrice dans deux variables distinctes \texttt{height} et respectivement \texttt{width}.

\begin{verbatim}
   public DataStructure(int height, int width);
\end{verbatim}
Le constructeur va prendre deux entiers en paramètres. Il va vérifier
si les entiers sont valides c'est à qu'ils ne soient pas négatifs ou nuls.

\begin{verbatim}
   public int getHeight();
   public int getWidth();
   public int getValue(int i, int j);
   public boolean setValue(int i, int j, int color);
\end{verbatim}
Nous avons préféré mettre nos variables (\texttt{matrix}, \texttt{height} et \texttt{width}) en
private pour éviter toutes modifications inattendues de notre
matrice. C'est pourquoi nous avons implémenté des accesseurs. Ce ne
sont pas des accesseurs directs. Il n'y a pas de risque de
modification inattendues.
La méthode \texttt{setValue} va modifier notre matrice en respectant la
contrainte exigeant que \texttt{i} et \texttt{j} doivent être compris entre 0 et respectivement
\texttt{height} et \texttt{width}.

Nous n'avons pas mis de restriction sur color, etant donné que la
structure de données ne gère pas les règles du jeu, elle ne sait pas
de quoi il s'agit exactement.

Cette méthode retourne un booléen qui renvoie \texttt{true}
respectivement \texttt{false} si la modification a pu être apportée ou pas.

\begin{verbatim}
   public void reset_matrix();
   public void print();
\end{verbatim}
La méthode \texttt{reset\_matrix} va, comme son nom l'indique, faire un
simple reset de la matrice.

La méthode \texttt{print} affiche la matrice.


\subsubsection{Tests de la matrice}

Nos différentes classes de test vont dériver de \texttt{junit.framework.TestCase}. Elles auront une méthode \texttt{setUp()}, exécutée avant chaque méthode de test, pour initialiser les tests et une méthode \texttt{tearDown()}, exécutée après chaque méthode de test , pour relâcher les données.\newline
Les méthodes de test n'auront pas de paramètres et retournent \texttt{void}. Leur nom commencera par \texttt{testXXX}.\newline
A l'intérieur des méthodes de test, on effectuera les actions de test souhaitées, et on
vérifiera qu'elles se passent correctement en utilisant des méthodes \texttt{assertXXX}.\newline


Ces tests consisteront à s'assurer que la structure de données, qui
représente notre grille de Puissance 4, est robuste.\newline

Le premier test envisagé sera d'instancier une \texttt{DataStructure} 6$\times$7
correspondant à la grille classique. Tout en vérifiant par les
accesseurs que les dimensions de la matrice sont celles attendues.

On réalisera ensuite des tests aux limites sur notre structure de
données, par exemple 0$\times$0. Pour continuer sur quelques tests
aléatoires 100$\times$100.

Nous allons tester des ajouts de valeurs prises de manière aléatoire
mais qui restent valides. Et vérifier le comportement de \texttt{setValue} aux bornes. Donc en valeur
\texttt{i} et \texttt{j} négatives ou supérieures à \texttt{height} et
à \texttt{width}.

\bigskip
Exemple :\newline
\texttt{testAddingMoreThan42Values()}\newline
Mettre une valeur à une position de la grille s'écrit : \texttt{matrix.setValue(i, j, c)}. Cette action doit retourner un booléen \texttt{true}, ce qui est testé par l'instruction :
\begin{center}
\texttt{assertTrue(matrix.setValue(i, j, c));}
\end{center}
Une fois toutes les cases de la grille remplies, le test d'ajout ne doit plus passer, ce qui s'écrira :
\begin{center}
\texttt{assertFalse(matrix.setValue(i, j, c));}
\end{center} 

Un \texttt{test aux limites} sera mis en place dans cette méthode : En plus de tester la possibilité que toutes les cases de la grille soient remplies, nous avons testé le rajout de valeurs à des positions \textit{hors limite}.\newline
Exemple :\newline
\texttt{assertFalse("Test aux limites : limite inf", matrix.setValue(-1, -1, 1));}\newline
\texttt{assertFalse("Test aux limites : limite sup", matrix.setValue(6, 0, 0));}

\subsection{Player}
\texttt{Player} est une interface permettant de basculer facilement entre un
\texttt{HumanPlayer} et un \texttt{CpuPlayer}. Nous reverrons cette partie dans le \texttt{GameEngine}.

\subsubsection{HumanPlayer}
\begin{verbatim}
    private int currently_played;
\end{verbatim}
Sert à mémoriser la position que le joueur a choisi.

\begin{verbatim}
    public int play(DataStructure grid, GUI gui);
\end{verbatim}
Cette méthode va attendre que le joueur fasse son choix à travers
l'interface graphique. Elle récupère aussi bien une position jouée
qu'un reset de la grille.Elle retourne la position choisit
par le joueur mais ne vérifie pas si elle est correcte. Cela s'effectue
plus loin dans le \texttt{GameEngine}.

\subsubsection{CpuPlayer}
\begin{verbatim}
    private int mode;
    private int currently_played;
    private Rules rule;
\end{verbatim}
La première variable stocke le mode; 0 pour deux humains, 1 pour
un ordinateur facile et 2 pour un ordinateur difficile.

La seconde variable, \texttt{currently\_played}, stocke la position
jouée par le joueur (humain ou ordinateur).

La troisième variable, \texttt{rule}, stock les règles du
jeu. Cela est utile pour l'ordinateur, afin de bien respecter les
règles lorsqu'il effectue un choix. Nous reverrons plus en
détail cette partie dans la classe \texttt{IaFourInARow} qui
implémente l'intelligence artificielle.

\begin{verbatim}
    public CpuPlayer(int mode, Rules rule);
    public int play(DataStructure grid, GUI gui);
\end{verbatim}

Notre première méthode est un constructeur. Elle attribue un \texttt{mode}
au CpuPlayer mais aussi les règles à utiliser (\texttt{Rules}).

Notre seconde méthode, \texttt{play}, est similaire à celle de
HumanPlayer. Elle va instancier l'intelligence
artificielle en fonction du mode choisi. Cela se fait à l'aide des lignes 21-22 :
\begin{verbatim}
     Cpu cpu1 = new IaFourInARow();
     cpu1.initialize(grid, mode);
\end{verbatim}
Si on veut utiliser une autre intelligence artificielle, il suffirait
de créer une nouvelle classe qui implémente \texttt{Cpu} et qui fonctionne
globalement comme l'IA actuelle. Notre Intelligence artificielle est
donc totallement indépendante du reste du programme et peut être
changée facilement.

\subsubsection{Jeux de test}
Tester la classe \texttt{HumanPlayer} se limitera à tester la méthode \texttt{play(DataStructure , GUI gui)}.\newline
Nous allons tester que la valeur de la position jouée n'est pas nulle
et qu'elle est comprise entre 0 et la largeur de la grille(7), cela
s'écrira :

\texttt{played = human.play(matrix,app);}

\texttt{assertNotNull(played);}

\texttt{assertTrue( 0 <= played \&\& played <
  matrix.getWidth());}

\bigskip
\subsection{Cpu}
\texttt{Cpu} est une interface. Le fait d'en avoir créé une va nous
permettre de pouvoir implémenter de nouvelles IA sans modifier plus
d'une ligne du code.

\subsubsection{IaFourInARow}
En ce qui concerne l'intelligence artificielle, nous avons choisi
d'en implémenter une séquentielle. Il n'y a aucune part
aléatoire. Cette IA n'implémente pas la stratégie gagnante. Nous nous sommes
renseigné sur celle-ci et il faudrait implémenté un arbre faisant intervenir des
statistiques de meilleurs coups à jouer. Cela ne semble pas évident au
premier abord à implémenter, c'est pourquoi nous avons implémenté une
IA $maison$ qui donne des résultats assez satisfaisants.

Cependant si on veut implémenter la stratégie gagnante cela est
possible en créant une classe qui implémente l'interface \texttt{Cpu}
et qui respecte le fonctionnement de l'IA actuelle comme décrit ci-après.

\begin{verbatim}
    private int mode;
    private DataStructure cpugrid;
    private int[] playable;
\end{verbatim}
Comme toujours le \texttt{mode} stocke la difficulté de l'IA, 1 pour
facile, 2 pour difficile.

\texttt{cpugrid} n'est pas une copie de la grille, mais un pointeur sur
la grille, donc si on modifie cpugrid on modifie aussi la grille de
puissance 4. Nous avons fait ce choix pour éviter de recopier la
grille à chaque fois, mais cela ajoute la contrainte de ne pas
modifier la grille lors du calcul de notre stratégie.

La variable \texttt{playable} va etre de la taille de
\texttt{width}. Elle va servir à déterminer quel colonne jouer ou
quelle colonne ne pas jouer. Tout cela se fait à l'aide d'un codage
simple.\newpage

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable0}
  \caption{\texttt{playable[i] = 0}}
\end{center}
\end{figure}
Dans ce cas, tous les playable[i] sont à 0. Nous
pouvons jouer sur n'importe quelle case. Seulement notre intelligence
artificielle choisiera de jouer au centre du jeu, car la probabilité
de gagner lors qu'on joue au centre est supérieure aux autres cas.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable10}
  \caption{\texttt{playable[i] = 1}}
\end{center}
\end{figure}

Si l'ordinateur joue sur la colonne 4, alors au prochain coups le
joueur humain pourra gagner avec une diagonale. Par conséquent
\texttt{playable[4]=1}. Ce code signifie que si l'ordinateur joue sur
cette colonne alors cela peut faire gagner le joueur humain.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable2}
  \caption{\texttt{playable[i] = 2}}
\end{center}
\end{figure}
Dans ce cas \texttt{playable[2] = 2}.Si l'ordinateur
joue sur la colonne deux, le joueur humain pourra le bloquer.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable3}
  \caption{\texttt{playable[i] = 3}}
\end{center}
\end{figure}
Dans ce cas \texttt{playable[2] = 3}. Par conséquent l'ordinateur peut
gagner au prochain coup, et jouera la position 2.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable4}
  \caption{\texttt{playable[i] = 4}}
\end{center}
\end{figure}
La colonne 1 est pleine donc \texttt{playable[1] = 4}. L'ordinateur
prend conscience qu'il ne pourra pas placer de jetons dans cette
colonne.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable5}
  \caption{\texttt{playable[i] = 5}}
\end{center}
\end{figure}
A ce moment du jeu, l'ordinateur remarque qu'il peut gagner en
ajoutant 2 pions. Par conséquent il va marquer \texttt{playable[4] =
  5} et \texttt{playable[5] = 5}.


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable1}
  \caption{\texttt{playable[i] = 6}}
\end{center}
\end{figure}
Dans ce cas la \texttt{playable[1] = 6} et \texttt{playable[4] = 6}. Et tous
les autres cas \texttt{playable[i]=0}. L'ordinateur va bloquer la
possibilité de mouvement de l'humain.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable6}
  \caption{\texttt{playable[i] = 6}}
\end{center}
\end{figure}
Si le joueur humain place un pion dans la colonne 4 il remportera la
victoire. Pour eviter de perdre aussi facilement on met
\texttt{playable[4]=6}, et l'ordinateur va bloquer la victoire du
joueur humain.

\begin{verbatim}
    private Rules rule;
    private int height;
    private int width;
\end{verbatim}
La première variable va contenir les règles du jeu qui sont utilisées,
dans notre cas ce sera pour le Puissance 4. Les deux variables
suivantes contiennent la hauteur, respectivement la largeur de notre \texttt{cpugrid}.

\begin{verbatim}
    private void strategy();
    private void breakStrategy();
    private void noPlayable();
    private void winningPlayable();
    private void fillPlayable();
\end{verbatim}
La méthode \texttt{strategie()} va parcourir la grille et calculer les
positions que l'ordinateur peut jouer pour pouvoir gagner en deux
coups. une fois qu'elle a repérer les colonnes et remplie en
conséquence \texttt{playable[i]}.

La méthode \texttt{noPlayable} a un double usage. tout d'abord elle
regarde si le joueur humain peut gagner au prochain coups. Dans ce cas
elle marque \texttt{playable[i] = 6} (i correspondant à la
colonne). Mais elle va aussi vérifier si en jouant dans une colonne cela
permet à l'humain, au coups d'après, de gagner la partie. Dans ce cas
\texttt{playable[i] = 1}.

Pour \texttt{winningPlayable()}, on regarde si l'ordinateur peut
gagner au prochain coups, et on marque la colonne correspondante par 3,
\texttt{playable[i] = 3}.

La méthode \texttt{fillPlayable()} quand a elle initialise
\texttt{playable[i] = 0} pour les colonnes ou on peut encore
jouer. En ce qui concerne les colonnes pleines, alors
\texttt{fillPlayable()} va mettre \texttt{playable[i]=4}.

\begin{verbatim}
    public void initialize(DataStructure grid, int difficulty);
    public int play(Rules new_rule);
\end{verbatim}
La méthode \texttt{initialize()} n'est pas un constructeur, mais comme
son nom l'indique, elle va initialiser le \texttt{Cpu}. Quand à la
méthode \texttt{play()} elle va vérifier selon le \texttt{mode},
autrement dit la \texttt{difficulty}, quel IA appeler.

\begin{verbatim}
    public int perfectCpu();
    public int easyCpu();
\end{verbatim}
Ces deux méthodes sont très similaires, à la différence que le
\texttt{perfectCpu()} appelle les méthodes \texttt{breakStrategy()} et
\texttt{strategy()}, ce que ne fait pas la méthode
\texttt{easyCpu()}. Le mode \texttt{easyCpu} est moins agressif que le
mode \texttt{perfectCpu()}, qui en passant n'est pas parfait \newline
Dans notre méthode \texttt{perfectCpu()} on commence par remplir la
grille avec \texttt{fillGrid()} et continue par vérifier si
on peut gagner au prochain coup à l'aide de la méthode
\texttt{winningPlayable()}. Si il y a une position gagnante alors on
retourne le numéro de la colonne. Sinon on regarde si le joueur humain
peut gagner au prochain coups, ou si jouer une certaine colonne peut
le faire gagner. Tout cela à l'aide de la méthode
\texttt{noPlayable()}.


Si on est dans le \texttt{perfectCpu()} alors on établie une
stratégie. Pour cela on évite de jouer une colonne ou l'humain
pourrait nous bloquer par la suite, avec la méthode
\texttt{breakStrategy()}. Ensuite on essaie d'établir une stratégie,
si on a 2 jetons alignés, alors on va essayer d'en aligner 2 de plus
pour faire un 4 à la suite, à l'aide de la méthode
\texttt{strategy()}. Cela ne se fait que dans la méthode \texttt{perfectCpu()}


On continue, peu importe la méthode \texttt{perfectCpu()} ou
\texttt{easyCpu()}, on regarde si on a autre chose que des 0, 1 et 2
dans \texttt{playable[i]}, et dans ce cas on remplit les colonnes du
milieu de la grille. Sinon dans l'ordre des priorités pour
\texttt{playable[i]} l'ordinateur joue de cette manière : \texttt{3 -
  6 -  5 -  0 -  2 -  1}.

\subsubsection{Jeux de test}

Nos données de tests devront permettre de couvrir l'ensemble des
retours de l'IA (mode facile et difficile) et des stratégies , c'est à dire :
\begin{itemize}
\item L'ensemble des coups possibles de l'ordinateur (toutes les
  colonnes de la grille).
\item L'ensemble des valeurs de \texttt{playable} possible.
\item Un retour d'erreur en cas d'impossibilitée de jouer.
\end{itemize}

Une donnée de test est composé de :
\begin{itemize}
\item Un grille vide , pleine , ou partiellement remplie.
\item un mode de difficulté : deux sont prévus.
\item Des règles de jeux (ici règles standard).
\end {itemize}

Pour cela nous allons reprendre les grilles d'exemples ci dessus afin de
d'atteindre tout les valeurs possible de \texttt{playable},en y
ajoutant une grille pleine pour le code d'erreur.  Nous devons tester
ces grilles avec les deux modes de difficulté et avec les règles
standard du puissance 4. Nous obtiendrons ainsi un jeu de test couvrant
un maximum de cas d'état de l'IA et soulevant un maximum de
comportement inattendut.

\subsection{Rules}

\texttt{Rules} est une interface. Cela nous permet d'implémenter de
nouvelles règles. Ca peut être utile si on veut transformer notre
Puissance 4 en Morpion, ou si on veut faire un Puissance 5 ...

\subsubsection{FourInARow}
Cette classe implémente \texttt{Rules}.

\begin{verbatim}
    public boolean checkDiag(int i, int j, int color, DataStructure grid);
    public boolean checkCol(int i, int j, int color, DataStructure grid);
    public boolean checkLine(int i, int j, int color, DataStructure grid);
    public boolean isComplete(DataStructure grid);
    public boolean checkPlay(int play, DataStructure grid);
    public void greyOut(GUI app, DataStructure grid);
\end{verbatim}

\texttt{checkDiag()} retourne \texttt{true} si il existe un alignement
de 4 jetons d'une même couleur en diagonale. Il retourne
\texttt{false} sinon. \texttt{checkCol()} retourne \texttt{true} si il existe un alignement
de 4 jetons d'une même couleur en colonne. Il retourne
\texttt{false} sinon. \texttt{checkLine()} retourne \texttt{true} si il existe un alignement
de 4 jetons d'une même couleur en Ligne. Il retourne
\texttt{false} sinon. \texttt{isComplete()} va faire appel aux trois
méthodes précédentes afin de vérifier si il y a un gagnant. Auquel cas
cette méthode retourne \texttt{true}, sinon elle renvoie
\texttt{false}. La méthode \texttt{checkPlay()} vérifie que la
position passée en argument est jouable, elle renvoie \texttt{true} si
cést jouable, et \texttt{false} sinon.

La dernière méthode, \texttt{greyOut()}, va quand à elle griser les bouttons des colonnes
pleines correspondantes.

\subsubsection{Tests de FourInARow}
Cette classe testera :\newline 
\begin{itemize}


\item L'existence ou non d'un alignement de 4 jetons d'une même couleur soit dans la même ligne, même colonne, même diagonale :\newline
On choisira des valeurs exhaustives valides (constituant une : ligne, colonne, diagonale) afin de vérifier le comportement de nos méthodes d'alignement des jetons.\newline
Exemple (Existence de 4 jetons sur la même ligne) :\newline
On créera 4 jetons sur la même ligne 0:\newline
\begin{center}
\texttt{assertTrue(matrix.setValue(0, 0, 1));}\newline
\texttt{assertTrue(matrix.setValue(0, 1, 1));}\newline
\texttt{assertTrue(matrix.setValue(0, 2, 1));}\newline
\texttt{assertTrue(matrix.setValue(0, 3, 1));}\newline
\end{center}

Puis en bouclant sur toutes les positions de la grille, on arrivera à
effectuer un test complet sur l'existence ou non d'un alignement de 4
jetons sur une ligne donnée.\newline

\begin{center}
\begin{verbatim}
                for (int i = -1; i <= matrix.getWidth(); ++i) {
					for (int j = -1; j <= matrix.getHeight(); ++j) {
						if (i == 0 && j>=0 && j < matrix.getWidth()- 2) {
							assertTrue(rule.checkLine(i, j, 1, matrix));
							assertFalse(rule.checkLine(i, j, 2, matrix));
						} else {
							assertFalse(rule.checkLine(i, j, 1, matrix));
							assertFalse(rule.checkLine(i, j, 2, matrix));
						}
					}
				}
\end{verbatim}

\end{center}


\item Tester qu'une position donnée est jouable en remplissant la grille
  aléatoirement mais de manière à ce qu'une position soit jouable/non
  jouable.  \newline

\item Tester qu'un coup sur la ligne 0 de la grille n'est pas jouable
s'écrira :\newline
\begin{center}

\texttt{assertTrue(matrix.setValue(0, 0, 1));\newline
assertTrue(matrix.setValue(0, 1, 1));\newline
assertTrue(matrix.setValue(0, 2, 1));\newline
assertTrue(matrix.setValue(0, 3, 1));\newline
assertTrue(matrix.setValue(0, 4, 1));\newline
assertTrue(matrix.setValue(0, 5, 1));\newline
assertTrue(matrix.setValue(0, 6, 0));\newline}
		
\texttt{assertFalse(rule.checkPlay(0, matrix));}\newline


\end{center}

\end{itemize}

\subsection{GameEngine}
\subsubsection{Implémentation}
\begin{verbatim}
    private DataStructure grid;
    private boolean current_player;
    private int currently_played;
    private GUI app;
    private int mode;
    private Rules rule;
    private Player player1;
    private Player player2;
    private int counter;
\end{verbatim}
La variable \texttt{grid} contient la grille du
jeu. \texttt{current\_player} peut obtenir deux valeurs, 0 qui
correspond au joueur 1, et 1 qui correspond au joueur
2. \texttt{currently\_played} contient le coup joué (une position ou un
reset). \texttt{app} contient l'interface graphique. \texttt{mode}
contient le mode de jeu. \texttt{rule} contient les règles du
jeu. \texttt{playerX} contient le joueur, qui peut etre humain ou
artificiel. \texttt{counter} contient le nombre de coups joué, cela
nous permet de déterminer si il y a un match nul.

\begin{verbatim}
    public GameEngine();
    public void initMode(int my_mode);
    public void close();
    public void start();
    public void resetGrid();
    public void updatePlay();

    private void updateGrid();
\end{verbatim}
Le constructeur initialise l'interface graphique, la grille (avec une
taille que l'on peut modifier) et les règles du jeu. La méthode
\texttt{initMode()} initialise les joueurs, la variable
\texttt{my\_mode} et reset le \texttt{counter}. La méthode
\texttt{close()} quand à elle ferme l'interface graphique. Cette
méthode n'est appelée que par le \texttt{Main()}.

La méthode \texttt{start()} s'occupe de lancer le jeu. il aura été
initialisé par les autres méthodes qui la précède.\newline
La boucle \texttt{while((!rule.isComplete(grid)) \&\& (counter <} 
\texttt{grid.getWidth() * grid.getHeight()))} va faire en sorte que le jeu
ne se termine pas tant qu'il n'y a pas de gagnant ou que la grille
n'est pas pleine. Il faut savoir que l'utilisateur peut arrêter le
programme a tout moment a l'aide de l'interface graphique.

Cette méthode fiat jouer a tour de rôle le joueur 1 et le joueur
2. C'est la méthode \texttt{start()} qui va interpréter le choix du
joueur, autrement dit, si \texttt{currently\_played = -2} ca implique
qu'il faut reset la grille.

A chaque tour de boucle on incrémente la variable \texttt{counter} de
un si la position jouée est valide. Par la suite on met à jour la
grille à l'aide de la méthode \texttt{updatePlay()} et on grise les
bouttons dont les colonnes sont pleines à l'aide de la méthode
\texttt{rule.greyOut()}.

Une fois la boucle terminée, autrement dit, lorsque le jeu est terminé
on vérifie qui a gagné et on l'affiche à l'aide de la méthode \texttt{gameEnded()}.

La méthode \texttt{resetGrid()} s'occupe d'initialiser la
\texttt{grid} avec des 0, elle fait en sorte de ne aps re-faire
appelle à elle avec la méthode \texttt{app.setReset(false)} et
réinitialise tous les boutons avec la méthode
\texttt{app.enableAllButton()}. Il faut aussi réinitialiser le
\texttt{counter} et mettre à jour l'affichage graphique.

La méthode \texttt{updatePlay()}, va quand à elle, re-vérifier si la
position jouée est valide puis va mettre à jour la grille, et enfin
met à jour l'affichage.

La méthode \texttt{updateGrid()} va mettre à jour la grille, autrement
cést elle qu iva générer la gravité, si on peut dire.

\subsubsection{Tests du GameEngine}
%%Pour valider le fonctionnement du GameEngine qui s'avére délicat à tester correctement
%%avec JUnit nous avons choisis une autre approche. Nous avons crée une
%%classe IARandom qui va nous servir uniquement à tester de manière
%%aléatoire le fonctionnement de notre moteur de jeu. Cette IA tire au
%%sort une colonne et joue un pion dans cette colonne si le coup est
%%valide sinon elle tire de nouveau une colonne au sort.

Nous devons élaborer des tests fonctionnels pour la classe \texttt{GameEngine} afin de vérifier la conformité du déroulement du jeu et les données retournées par la classe.\newline
Les méthodes seront \texttt{testHuman2WinHuman1()}, \texttt{testCpu1WinHuman()} et \texttt{testCpu2WinHuman()} qui lancent respectivement des confrontations Humain/Humain, Cpu1/Humain et Cpu2/Humain.\newline
Elles auront pour rôle respectivement de :\newline
\newline
\begin{itemize}
\item Tester que lors de la confrontation Humain1/Humain2 c'est le joueur humain2 qui a gagné et envoyer un message d'erreur dans le cas contraire.\newline
\begin{center}
\texttt{assertFalse("2 possibilités : $\backslash$n C'est le joueur humain numéro 1 qui a gagné !!!$\backslash$n" +
				"ou personne n'a gagné !!", game.getWinPlayer());}
\end{center}
\item Tester que lors de la confrontation Cpu1/Humain c'est le joueur Cpu1 qui a gagné et envoyer un message d'erreur dans le cas contraire.\newline
\begin{center}
\texttt{assertFalse("C'est l'humain qui a gagné !", game.getWinPlayer());}
\end{center}

\item Tester que lors de la confrontation Cpu2/Humain c'est le joueur humain2 qui a gagné et envoyer un message d'erreur dans le cas contraire.\newline
\begin{center}
\texttt{assertFalse("C'est l'humain qui a gagné !", game.getWinPlayer());}
\end{center}
\end{itemize}


Une dernière méthode \texttt{testModes()} va tester la mise-à-jour des modes de jeu.\newline
Exemple :

\texttt{assertTrue(game.initMode(0));}

\texttt{assertTrue(game.getMode() == 0);}

\texttt{assertFalse(game.getMode() == 1);}

\texttt{assertFalse(game.getMode() == 2);}



\subsection{Main et Menu}
Le \texttt{Main()} va instancier le \texttt{GameEngine} mais aussi le
menu de départ. cést le \texttt{Main()} qui va dire au
\texttt{Gameengine} de démarrer le jeu avec l'appel à la méthode
\texttt{g.start()}. Le \texttt{Main()} fait au \texttt{GameEngine}
instancier les joueurs avec l'appel à la méthode
\texttt{g.initMode(my\_menu.choice)}.\newline
\newline
En ce qui concerne le menu, on aurait pu l'intégrer dans l'interface
graphique, mais nous n'avions pas assez de temps pour faire cette
petite modification, et nous avons préféré passer aux tests directement.

\subsection{GUI}

\texttt{GUI} est une interface, cela nous permettra, au besoin, de brancher une autre interface graphique à notre application.

\subsubsection{GuiOwn}
Cette classe, implémente \texttt{GUI}. 
\begin{verbatim}
    public int choice;
    public boolean played;
    public boolean reset;
    public boolean game_ended;
\end{verbatim}
La première variable \texttt{choice} contient la colonne sélectionné par le joueur humain. La seconde variable \texttt{played} est à \texttt{true} lorsqu'un joueur a choisi une colonne et est à \texttt{false} sinon. Il en est de même pour \texttt{reset} et pour \texttt{game\_ended}. A savoir que \texttt{reset} concerne le reset de la grille et \texttt{game\_ended} dit si le jeu est terminé ou non.

\begin{verbatim}
    public abstract void initGui(DataStructure grid);
\end{verbatim}
Cette méthode initialise l'interface grapique en créant autant de colonne et de ligne que la matrice en a.

\begin{verbatim}
    public abstract void updateScreen(DataStructure my_grid);
\end{verbatim}
\texttt{updateScreen} met a jour l'affichage de la grille.

\begin{verbatim}
    public abstract void gameEnded(boolean winner);
    public abstract void gameEnded();
\end{verbatim}
La première méthode affichage le nom du joueur dans l'interface graphique, et la seconde affiche Match nul.

\begin{verbatim}
    public abstract void greyAllButton();
\end{verbatim}
Cette méthode grise tous les bouttons qui permettent de choisir les colonnes mais aussi de faire un reset de la grille. Elle est utilisé lorsque le jeu est terminé.

\begin{verbatim}
    public abstract void enableAllButton();
\end{verbatim}
Cette méthode rend tous les bouttons correspondant aux colonnes non-grisés. Elle est utilisée lors d'un reset.

\begin{verbatim}
    public abstract void greyButton(int num);
\end{verbatim}
\texttt{greyButton()} grise le boutton de la colonne correspondante à num.

\begin{verbatim}
    public void setSize(int i, int j);
    public void setLocation(int i, int j);
    public void show();
    public abstract void dispose();
\end{verbatim}
La première méthode permet de définir la taille de la fenêtre de jeu. La seconde sert à définir la position de la fenêtre par défaut. La troisième est une méthode définit dans les librairies de \texttt{Swing} qui permet d'afficher l'interface graphique. Quand à la dernière méthode, elle permet d'afficher/fermer une fenêtre. La méthode \texttt{dispose()} est aussi définit dans les librairies de \texttt{Swing}.

\begin{verbatim}
    public boolean getPlayed();
    public int getChoice();
    public void setPlayed(boolean played);
    public boolean getReset();
    public void setReset(boolean reset);
\end{verbatim}
Ces trois méthodes sont de simples accesseurs aux variables correspondantes.
