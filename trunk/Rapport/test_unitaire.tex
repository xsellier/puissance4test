% -*- mode: latex; coding: latin-1-unix -*- %

\subsection{Tests Unitaires}

\subsubsection{DataStructureTest}

La plupart des bugs identifiés seront liés aux valeurs des positions de la grille.\newline
Particulièrement, une affectation d'une couleur à une position \textbf{hors limite} est source 
de bugs.\newline
Le fait d'affecter une couleur quelconque à la position \textbf{(0,9)} d'une grille (8,9) est typiquement le type de bugs qu'on aura à traiter.

\paragraph{Test 1} - Résultats

\begin{verbatim}
    public void testInvalidSetValues() {
        assertFalse(matrix.setValue(10, 1, 0));
        assertFalse(matrix.setValue(1, 10, 1));
        assertFalse(matrix.setValue(10, 10, 2));
    }
\end{verbatim}
   
Ce test montre bien qu'il n'est pas possible d'affecter des couleurs \textbf{hors des limites} 
à la grille \textbf{matrix} (6,7) considérée.

\paragraph{Test 2} - Résultats

\begin{verbatim}
    public void testNegativeMatrix() {
        int resultNH = negative_matrix.getHeight();
        assertEquals("la hauteur d'une negative_matrix n'est pas  6", resultNH, 6);

        int resultNW = negative_matrix.getWidth();
        assertEquals("la largeur d'une negative_matrix n'est pas  6", resultNW, 7);
   }    
\end{verbatim}

Ce test montre que les paramètres (height , width) d'une grille "négative" n'ont 
de valeur que respectivement 6(hauteur) et 7(largeur).  \newline
Ce même type de test sera experimenté sur une grille "zero" et donnera le même résultat.

\paragraph{Test 3} - Résultats

\bigskip
Tester \textbf{aux limites} la possiblité d'affecter des couleurs à une grille (6,7).\newline
Ce test peut être généralisé à des grilles (i,j) avec i>0 et j>0.\newline  

En effet, l'affectation des couleurs dans le Domaine des positions [0...42] réussit avec succès.
Mais, pour les valeurs -1 et 43 le test montre une impossibilité d'affectation.\newline

\subsubsection{IAfourInARowTest}

Ces tests nous ont permis de révéler de nombreux bugs liés aux comportements des IA. Tout d'abord sur les stratégies de \texttt{playable[]} qui n'étaient pas toujours juste par rapport à l'état actuel de la grille,et aussi la façon de jouer des IA ne correspondaient pas toujours à ce qui était attendu dû au fait des priorités des \texttt{playable}.

Pour chaque état de la grille il nous était possible à l'aide de l'algorithme de connaître l'état de \texttt{playable[]} et le coup que doit jouer l'IA ainsi nous avons corrigé les moteurs d'IA pour qu'ils nous donnent exactement les résultats escomptés dans les cas typiques ci-dessus.



\subsubsection{FouInRowTest}

La victoire d'un joueur est conditionnée par le fait qu'un joueur
aligne 4 jetons sur la même ligne, colonne ou diagonale. Ceci sera
testé au moyen des 3 méthodes \texttt{testCheckLine()},
\texttt{testCheckCol()} et \texttt{testCheckDiag()}. Le résultat
obtenu sera satisfaisant à la fois pour les tests d'alignement et
celui de la jouabilité d'un coup donné.(cf 4.4.2)\newline


\subsubsection{GameEngineTest}


Tester le moteur de jeu, nous permettra de vérifier correctement que
les modes initialement initialisés seront valides. Et dans un deuxième
temps, de tester les différents cas de figure de fin de
partie.\newline

Dans ce dernier point, les possibilités sont multiples et quelque unes
d'entres elles seront testés(cf 4.5.2). \newline
Mais, nous avons determiné tout de même un cas de figure non traité et
impossible à tester vu l'état actuelle de notre code, donc un bug lié
à notre implémentation.\newline
C'est lorsqu'un joueur joue le dernier coup de la partie(grille
remplie complètement) et aligne 4 jetons suite à ce même coup,
on est incapable de désigner le vainqueur comme étant celui qui a joué
en dernier.\newline