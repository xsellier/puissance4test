
\section{Introduction}

La démarche que nous nous sommes efforcés d'adopter dans ce projet est la suivante. Nous avons suivi le processus du cycle en "V" en concevant les différents niveaux de tests au fur et à mesure de la conception du programme. Nous avons essayé de parcourir ce schéma horizontalement autant que possible, à savoir qu'avant de descendre à un niveau de détail plus élevé, nous nous sommes assurés de concevoir les tests associés au niveau en cours.
Le projet étant un exercice scolaire et non pas une application industrielle, les tests du haut du cycle en fin sont plus délicats à mener. Il n'y a pas de "client". Le rapport suit également cette démarche du cycle en "V". Ainsi, chaque partie de la conception sera suivie des tests correspondant à leur contenu.

\section{Spécifications}
Le programme ici spécifié donne la possibilité à un utilisateur de jouer au jeu 'Puissance 4' dans les conditions décrites ci-dessous:

\subsection{Application des règles de puissance 4}

Règles concernant les joueurs:\newline
Le jeu fait intervenir deux joueurs. Chaque joueur possède des jetons d'une couleur propre et ajoute lors de chaque tour un jeton dans une des colonnes d'une grille de dimensions n x m (par défaut 6 x 7). Un joueur est déclaré gagnant s'il aligne quatre jetons consécutifs verticalement, horizontalement ou en diagonale dans la grille. Si la grille est remplie alors qu'aucun joueur n'a été déclaré gagnant, la partie est nulle.\newline\newline

Propriétés de la grille:\newline
Pour jouer à Puissance 4, on utilise comme support une grille dont les dimensions standard sont de 6 lignes et 7 colonnes, que l'on numérotera respectivement de 0 à 5 et de 0 à 6. Ce support doit être présent dans notre programme.\newline\newline

Déroulement de la partie:\newline
Au début de la partie, la grille est vide. Pendant la partie, des jetons de 2 couleurs différentes sont ajoutés successivement dans la grille jusqu'à ce qu'elle soit remplie ou que l'un des joueurs forme un alignement de 4 jetons de sa couleur. Un jeton est ajouté à la grille en fournissant le numéro de colonne. En effet, le numéro de ligne ne fait pas partie du choix du joueur dans le sens où un jeton descend nécessairement au niveau le plus bas accessible dans la grille. Par exemple, le premier jeton descend à la ligne numero 5 (la plus basse). Si une colonne est remplie (6 jetons ont été insérés dans la même colonne), aucun joueur ne peut jouer de jeton dans cette colonne jusqu'à la fin de la partie.\newline\newline

On s'assurera que chacune de ces règles sera respectée dans notre programme.\newline

\subsection{Configurations de jeu et types de joueurs}

 Un joueur peut être un humain ou une entité controllée par l'ordinateur. Ainsi, on peut avoir les configurations de jeu suivantes: cpu vs joueur ou joueur vs joueur.
Quelle que soit la configuration, le programme contiendra une entité représentant le joueur 1 et le joueur 2. En fonction du mode choisi par l'utilisateur, le joueur 2 sera humain ou controllé par l'ordinateur. Le joueur 1 sera toujours humain. Un humain commence toujours la partie.\newline\newline

- IA : tous les deux tours la main est donnée à l'ordinateur. On veut pouvoir choisir différents niveaux de difficulté (i.e: l'ordinateur est plus ou moins performant selon le niveau choisi). Il doit être possible d'ajouter de nouveaux modes de difficulté facilement. Chaque niveau sera représenté par un algorithme qui déterminera le prochain coup que l'ordinateur va jouer (i.e le prochain numéro de colonne).\newline\newline

- humain : tous les deux tours la main est donnée à l'utilisateur. A chaque fois que le tour d'un humain vient, le programme attendra que l'utilisateur saisisse son choix.\newline\newline

\subsection{Visualisation}

 L'utilisateur du programme doit pouvoir visualiser en temps réel le déroulement du jeu, c'est-à-dire les coups joués par l'ordinateur ou l'humain. Dans un premier temps, on utilisera un affichage en mode console, puis si le planning le permet, une interface graphique plus agréable pour l'utilisateur. L'outil de visualisation doit être facilement interchangeable.\newline
En premier lieu, l'utilisateur doit pourvoir choisir, au travers de l'interface, quel type de configuration il souhaite utiliser et instancier une partie.\newline
Ensuite, lors du déroulement de la partie, il doit pouvoir connaître grâce à l'affichage quels sont les coups qui ont été joués jusqu'à l'instant où il lui est demandé de jouer. Enfin, il doit pouvoir interagir avec le panneau visuel de manière à faire connaître son choix pour le coup en cours au programme lorsque c'est à lui de jouer. Lorsqu'une partie est terminée, l'utilisateur doit être averti de l'issue de celle-ci (joueur 1 gagne, joueur 2 gagne ou match nul).
Eventuellement, il doit alors pouvoir jouer une nouvelle partie.\newline


\subsection{Tests de validation}

Nous allons voir ici les tests imaginés pour s'assurer que le programme obtenu respectera les termes précisés dans la partie précedente, et ne génèrera pas de comportements interdits.\newline\newline


\subsubsection{Règles de puissance 4}
Voici les tests système liés aux règles du jeu :\newline

\begin{itemize}
\item \texttt{Test 1}\newline
On lance toutes les configurations disponibles dans le menu et on vérifie que deux entités peuvent jouer des coups de couleur différente.\newline\newline

\item \texttt{Test 2}\newline
On instancie une grille de taille 6x7 puis de tailles différentes.\newline\newline

\item \texttt{Test 3}\newline
On utilise le mode humain vs humain pour arriver à une partie nulle et on vérifie que l'on est averti de cette issue.\newline\newline
\end{itemize}

On soumettra ensuite le programme à un échantillon d'utilisateurs connaissant les règles et on receuillera leur avis concernant leur application.\newline

\begin{itemize}
\item \texttt{Test 4}\newline
Demander aux personnes composant l'échantillon si elles jugent que les règles de puissance 4 attendues ont été respectées pendant leur partie.
\end{itemize}

Enfin, on pourra utiliser le joueur ordinateur pour générer des parties aléatoires et en vérifiant à chaque fois que l'empilement des pions respecte les règles.\newline

\begin{itemize}
\item \texttt{Test 5}\newline
Générer des parties aléatoires et vérifier les coups joués.
\end{itemize}

\subsubsection{Configurations de jeu}

Il suffit d'un test fonctionnel basique dont l'objet est de vérifier que lorsque le programme est lancé, les différentes configurations de jeu sont disponibles.\newline\newline

\begin{itemize}
\item \texttt{Test 6}\newline
Essayer chaque action possible dans le menu lance et vérifier que l'on obtient la configuration attendue.\newline
\end{itemize}

\subsubsection{Types de joueurs}

On vérifiera que des moyens de modularité permettant d'interchanger la façon dont l'ordinateur joue on été mis en place (voir section intégration).\newline
On implémentera alors si possible de nouveaux niveaux pour vérifier cette modularité.\newline

\begin{itemize}
\item \texttt{Test 7}\newline
Test exhaustif d'exécution vérifiant qu'au moins deux niveaux de jeu sont présents.\newline
\end{itemize}



\subsubsection{Visualisation}

Les tests de visualisation n'étant pas l'objectif de ce projet nous résumerons les tests à effectuer comme suivant, et ne présenterons pas de résultats dans la partie correspondante. On admettra que l'interface graphique sera exempte de bug dans la suite du rapport.\newline

On vérifiera que lorsque le programme est lancé, il est possible à tout moment de jouer l'ensemble des coups autorisés. Ceci peut être effectué à la fois manuellement et automatiquement grâce à un mode ordinateur aléatoire. Rappelons ici qu'un joueur ordinateur aléatoire ne devra alors être présent que dans une situation de test et non pas dans la version livrable du programme. Ce type de joueur devra être testé séparément pour s'assurer que les conclusions tirées de son utilisation ne sont pas faussées par nature.\newline
Dans le cas d'une interface graphique, chaque bouton sera testé dans une démarche exhaustive.\newline\newline

Il est nécessaire de rappeler qu'en raison de la simplicité du jeu ici modélisé, les tests systèmes ne représentent pas une difficulté élevée et il sera trivial de vérifier la plupart de ces spécifications dans la mesure ou les tests unitaires et les tests d'intégration (décrits plus tard) seront passés avec succès.

