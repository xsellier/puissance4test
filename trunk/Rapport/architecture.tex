% -*- mode: latex; coding: latin-1-unix -*- %

\section{Architecture}
Nous allons décrire ici les différents modules imaginés pour répondre aux attentes formulées dans la partie spécification.\newline

\subsection{Structure de données}

Nous implémenterons une classe contenant un tableau d'entiers et les différentes méthodes nécessaires aux accès en écriture et lecture sur celui-ci. Ainsi, on doit pouvoir instancier un tableau de dimensions variables, initialiser ses valeurs et les modifier. Le tableau doit également pouvoir être réinitialisé. Cette classe a pour but de représenter la grille et donc les coups joués par chaque joueur au long de la partie. On représentera une case vide par un entier nul à la position correspondante. Un entier dont la valeur est à 1 représentera un coup joué par le joueur 1, même chose pour le joueur 2.\newline
C'est ce module qui va permettre au joueur ordinateur de connaître les possibilités de jeu à chaque tour (coups jouables). C'est grâce à cette représentation également que l'on saura si la partie est terminée ou non. Enfin, l'interface sera mise à jour à chaque tour en fonction de ce tableau, ce qui évitera des possibilités de confusion entre les deux entités.\newline

\subsection{Joueurs}

Il sera nécessaire d'implémenter 2 classes différentes pour les 2 types de joueurs. Cependant, certaines méthodes ou variables étant communes à ces entités on prévoiera une interface regroupant les méthodes nécessaires au jeu et appelées quelque soit le type de joueur. Ceci permettra au module en charge du déroulement du jeu de faire abstraction de la configuration choisie, et donc de diminuer le volume de code.

\subsubsection{Humain}

Le joueur humain aura une connexion étroite avec l'interface choisie. En effet, jouer un coup reviendra à interroger l'utilisateur via cette interface. Cette classe sera donc relativement peu volumineuse et d'une complexité faible.


\subsubsection{Ordinateur}

L'entité représentant le joueur artificiel sera plus importante. On devra pourvoir choisir entre 2 niveaux de difficultés, ce qui se traduira par une instanciation selon un paramètre particulier, comme un entier ou un boolén. Ainsi, la classe représentant ce type de joueur contiendra des méthodes différentes et correspondant chacune à ce niveau et donc paramètre choisi. On choisira premièrement un algorithme simple représentant une stratégie triviale (exemple: jouer la même colonne ou une colonne voisine de  celle choisie par le joueur 1 précédemment), puis on cherchera à implémenter un algorithme plus 'intelligent' permettant au joueur humain de se confronter à une difficulté de jeu élevée. On se rapprochera d'une stratégie gagnante pour le joueur-ordinateur.

\subsection{Règles}

Nous avons choisi d'implémenter un module destiné à l'application des règles tout au long de la partie. De manière plus spécifique, nous nous intéressons ici à la detection d'une situation incorrecte, d'une situation de terminaison ou bien du simple déroulement d'un coup joué.\newline

\begin{itemize}
\item Situation incorrecte \newline
La principale situation incorrecte dans notre système correspond au cas où un joueur tente d'ajouter un jeton dans une colonne déjà pleine. Le module en question contiendra les méthodes nécessaires à la detection de ce type de coup, méthodes que l'on utilisera alors pour avertir l'utilisateur de cette interdiction.\newline\newline

\item Situation de terminaison \newline
Une situation de terminaison se produit dans deux cas :\newline
Premièrement, un joueur aligne 4 pions dans la grille.\newline
Deuxièmement, la grille est remplie.\newline
De la même manière, on souhaitera que ces évènements soient détectés et traités en conséquence. C'est à dire, information de l'utilisateur et terminaison éventuelle du programme.\newline\newline


\item Déroulement d'un coup joué \newline
Lorsqu'un joueur communique son choix pour le coup en cours, le tableau d'entiers doit être modifié en conséquence. Nous avons décidé d'affecter cette tâche à ce module, qui sera donc en étroite corrélation avec la structure de données. Pour effectuer cette modification, la méthode correspondante aura connaissance du numéro du joueur en cours et la colonne choisie par ce joueur. L'action sera alors traduite par une affectation en accord avec les méthodes de la structure de données.\newline
\end{itemize}

L'ensemble de ces outils permettront au moteur de jeu décrit ci-dessous d'assurer le bon déroulement du jeu et donc du programme.

\subsection{Moteur de jeu}

Le moteur de jeu sera le coeur de notre programme dans le sens où il mettra en rapport l'ensemble des entités du programme. Ainsi, il devra assurer le scénario standard suivant :

\begin{enumerate}
\item Phase d'initialisation
\item Phase de jeu (a)
\item Phase de modification (b)
\item Phase de communication (c)
\item Terminaison ou nouvelle partie
\end{enumerate}

La phase d'initialisation correspond à la création et au lancement de chacun des modules cités dans cette section: une grille de dimension choisie sera initialisée, les joueurs seront instanciés conformément au choix initial de l'utilisateur, l'interface utilisateur sera lancée au besoin, une instance du module de règles sera créée.\newline\newline

La phase de jeu correspond à l'ordonnancement des coups des joueurs. Tour à tour, le moteur de jeu consultera le joueur concerné et lui demandera de fournir le numéro de colonne qu'il souhaite jouer, qu'il soit humain ou ordinateur.\newline\newline

La phase de modification permettra de traduire ce choix en une consultation du module de règles et modification de la grille en conséquence.\newline\newline

La phase de communication représentera la notification au joueur via l'interface de la configuration actuelle du jeu. Ainsi, dans le cas d'une interface graphique on mettra à jour l'affichage du panneau en fonction du nouvel état de la grille.\newline\newline

Ces trois dernières phases (a-b-c) seront répétées jusqu'à ce qu'une situation de terminaison apparaîsse.\newline\newline

Enfin, l'utilisateur choisira de terminer le programme ou de jouer une nouvelle partie. Le module de jeu sera donc capable de se réinitialiser pour revenir à une configuration initiale.\newline\newline

Chacune de ces phases sera représentée par une ou des méthodes contenue dans une classe dédiée.\newline

\subsection{Composants annexes}

On trouvera d'autres classes d'importance mineure :\newline \newline 

Une classe main sera présente et permettra d'instancier le moteur de jeu au démarrage du programme en lui communiquant le choix de configuration de l'utilisateur. D'autres interfaces pourront être ajoutées pour augmenter la modularité du programme.\newline
Enfin, dans le cas d'une interface graphique, il sera nécessaire de représenter chaque position de la grille grâce à des éléments graphiques changeant de couleur. De la même manière, d'autres composants graphiques permetront à l'utilisateur de communiquer son choix quant au coup qu'il veut jouer. On trouvera également une zone graphique destinée à l'avertir de la terminaison de la partie.


\subsection{Tests d'intégration}

Une fois les tests JUnit terminés, il nous faudra prévoir des tests
d'intégrations.
Nous saurons alors que chaque partie fonctionnera correctement
indépendamment.




\bigskip
\bigskip
=================

     SCHEMA A DEPLACER

     =================

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.5]{premiere_architecture}
  \caption{\texttt{Notre première architecture}}
\end{center}
\end{figure}

\paragraph{Moteur de jeu} - interaction avec les autres modules.

\bigskip
Nous sommes conscient que ce sera notre moteur de jeu qui va prendre
le plus de temps pour nos tests d'intégrations. C'est lui qui va
instancier notre structure de données, nos joueurs, nos règles ainsi
que l'interface graphique.

C'est pourquoi nous ne mettrons dans cette partie que les données de tests
qui concernent les différents modules avec le moteur de jeu.

\paragraph{Structure de données} - instanciation et modification(s)

\bigskip
\begin{itemize}

\item Instanciation correcte\newline
Lors du lancement du jeu, notre moteur va instancier notre structure
de données. Nous avons déjà pensé que ce sera une matrice, qui devra
être, d'après les spécifications, de taille minimale 6$\times$7. Nous devrons
vérifier que lorsqu'une grille correcte est instanciée, l'objet
retourné soit un objet de la taille souhaitée.
\bigskip
\item Instanciation incorrecte\newline
Dans un soucis de robustesse, nous pensons traiter le cas ou une
grille de taille incorrecte soit instanciée par notre moteur de
jeu. Autrement dit une grille de taille inférieure à 6$\times$7.
Pour mieux comprendre, si un utilisateur vient a modifier notre code
pour instancier une grille trpo petite, notre structure de données
doit en tenir compte est construire une grille de taille minimale 6$\times$7.
\bigskip
\item Lecture/Modification correcte\newline
Lors d'une partie notre moteur de jeu doit pouvoir lire et modifier
sans difficulté la grille. Nous devrons tester si les modifications
apportées par notre moteur de jeu soient bien effectuées par notre
structure de données et comparer les valeurs que notre moteur jeu lit
dans notre structure de données avec celles renvoyée par notre
structure de données.
\bigskip
\item Lecture/Modification incorrecte\newline
Encore une fois, dans un soucis de robustesse, la structure de données
devra pouvoir traiter des saisies incorrecte. Pourtant cela ne
ne veut pas dire qu'elle devra les interpréter, mais plutôt qu'elle
signifiera à l'utilisateur qu'il y a eu une mauvaise saisie à travers
la console, et renvoiera un booléen \texttt{false}.
\end{itemize}

\paragraph{Joueurs} - instanciation et interaction

\bigskip
\begin{itemize}

\item Instanciation\newline
Lorsque nous créons un joueur, il ne peut être que créé
correctement. Nous ne trouvons pas encore d'utilité a un constructeur
prenant en compte des paramètres.
La seule chose qui sera a vérifier, sera le type de l'instance du
joueur. A savoir si c'est bien un ordinateur, ou alors un humain.
\bigskip
\item Interaction\newline
Nous devrons vérifier que les coups joués par l'ordinateur sont bien
ceux récupérés par le moteur du jeu. Il faudra aussi vérifier que si
l'ordinateur renvoie une valeur impossible, par exemple une colonne
pleine, cela ne perturbe pas le fonctionnement du programme, mais
demande une nouvelle valeur à l'ordinateur.
De la même manière on devra vérifier que la grille fournit à
l'ordinateur par le moteur de jeu, corresponde a celle du moteur de
jeu. Et une fois que l'ordinateur a joué, il faudra vérifier que la
grille n'ait pas été modifié par notre intelligence artificielle, car
ce sera le job de notre moteur de jeu.
\end{itemize}

\paragraph{Règles} - instanciation et utilisation

\bigskip
\begin{itemize}

\item Instanciation\newline
Nos règles ne prennent aucun argument, donc leur instanciation
ne devraient pas poser de problème.
\bigskip
\item Utilisation correcte\newline
Il faudra soumettre aux règles une grille correcte et vérifier
qu'elles ne modifient pas cette grille. Dans le cas ou il y a un
gagnant nos règles devront nous le spécifier.
\bigskip
\item Utilisation incorrecte\newline
Nous espérons avoir un module robuste pour gérer les accès incorrects
fait par le moteur de jeu, mais aussi des grilles incorrectes. Avec
plusieurs gagnants, et encore une fois voir si nos règles valides ou
non ces grilles.
\end{itemize}

Notons que notre moteur de jeu utilisera toutes les méthodes de notre
structure de données, ainsi que de nos règles. Donc si l'interaction
entre notre moteur de jeu, notre structure de données et nos règles
sont correctes, alors si un autre module utilise de la même manière la
structure de données et les règles, et bien ce dernier module
fonctionnera sans modifications ni tests nécessaire.

Ce cas devrait surement s'appliquer a notre intelligence artificielle
qui devrait être capable de calculer des positions possibles. Pour se
faire, l'intelligence artificielle devra interagir avec les règles et
aussi la structure de données.

\bigskip
 Et enfin, pour vérifier de nouveau, que notre logiciel marche, en d'autres
terme que nos modules interagissent correctement, nous pensons
intégrer un mode débogue qui ne serait accessible qu'en mode de test.
