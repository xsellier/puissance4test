% -*- mode: latex; coding: latin-1-unix -*- %

\subsection{Tests d'intégration}
\subsubsection{Structure de données}

\begin{itemize}

\item \texttt{Test d'instanciation correcte}
  Nos différents tests d'intégration sur l'instantiation de la
  structure de données ont réussi. On retrouve exactement les
  dimensions correspondant aux valeurs entrées pour chaque grille
  testée. Ces grilles étant inspirées de l'analyse partitionnelle vue
  précédemment.

\item \texttt{Instanciation incorrecte}\newline
Dans le cas où le moteur de jeu initialise la grille avec des valeurs
incorrectes une grille par défaut est générée à la place. Ce test est
donc passé avec succès.



\item \texttt{Test de lecture/modification correcte}\newline
L'ensemble des tests unitaires effectué sur la structure de données et
sur les modules joueurs (humain ou ordinateurs) permettent de déduire 
que les valeurs échangées grâce au moteur de jeu sont toujours
correctes.


\item \texttt{Test de lecture/modification incorrecte}\newline
Des bugs d'indices ont été mis en évidence par ce test, désormais lors d'une saisie incorrecte la lecture ou l'écriture est ignorée et
un message est affiché dans le terminal.

\end{itemize}
\subsubsection{Joueurs}
\begin{itemize}

\item \texttt{Test d'instantiation}\newline
Un test exhaustif a montré que chaque bouton du menu permettait
d'initialiser le moteur de jeu avec le bon mode et que le type de
joueur correspondant était crée en conséquence.



\item \texttt{Tests d'interaction}\newline

\item Cohérence des coups\newline
Dans la fonction $start()$ du moteur de jeu, nous avons fait afficher
les coups joués par les joueurs dans le terminal et avons vérifié
qu'ils correspondaient aux coups choisis par le joueur. Nous avons
essentiellement vérifié les résultats grâce à des tests aléatoires en
mode humain vs humain.

\item Coups incorrects\newline
Dans le cas d'un choix incorrect, comme le numéro d'une colonne pleine
ou un numéro invalide, le programme ignorait ce coup et provoquait le
bug suivant: un joueur jouait 2 fois successivement. Nous avons alors
modifié le code de manière à ce que le moteur de jeu demande au joueur
de rejouer jusqu'à ce qu'il obtienne une valeur correcte. Ce type de
test est accessible avec l'option -test au lancement du programme. Le
nom des boutons permettant d'y accéder est Cpu Switch.

\item Intégrité de la grille \newline

De la même manière que pour la cohérence des coups, nous avons vérifié
grâce à des tests aléatoires et combinatoires que la grille n'était
pas modifiée lors d'un passage en paramètre. Nous avons utilisé la
méthode d'affichage de la structure de données pour ce faire.
\end{itemize}


\subsubsection{Règles du jeu}

Nous avons également utilisé les modes Cpu random et Cpu Switch pour
tester les actions suivantes:

\begin{itemize}

\item Séquences de jeu \newline
Test des différentes phases (voir Architecture) et de l'ordonnancement
des coups.
\item Intégrité de la grille\newline
 Test d'intégrité de la grille lors du passage à \texttt{Rules}
\item Condition de terminaison\newline
 Test des différentes combinaisons de victoire ou match nul
\end{itemize}


\subsubsection{Modularité}
Pour ajouter un nouveau de jeu et donc une intelligence artificielle, il fallait
modifier les classes \texttt{GameEngine} et \texttt{IAFourInARow} ce
qui ne correspondait pas aux exigences du test. Nous avons donc du
modifier l'architecture pour insérer des interfaces.

Voici un schéma représentant les zones du code concernées:

Nous avons du modifier le code et créer une nouvelle interface
\texttt{Cpu} dont le but était de permettre l'intégration d'une
nouvelle intelligence artificielle en ne modifiant qu'une seule ligne
de code. Ca a apporté une modificaiton simple et évidente sur notre
\texttt{CpuPlayer}.

On trouvait donc dans le moteur jeu :\newline
\texttt{IAFourInARow() cpu1 = new IAFourInARow();}

Qui est devenu :\newline
\texttt{Cpu() cpu1 = new IAFourInARow();}

Le changement est représenté par une classe
d'implémentation\texttt{IAFourInARow} pour l'interface \texttt{Cpu}.

Une modification similaire a été apportée au module graphique.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.5, angle=90]{diagrammefinal}
  \caption{\texttt{Architecture complète}}
\end{center}
\end{figure}