\section{Tests unitaires}

%%%%%%faut caser avant ou après les autres testes avec subsections%%%%%


\subsection{Tests sur les IA}

\subsubsection{Introduction}
Nous allons donc ici tester l'ordinateur reprendre les exemples de la partie implémentation IaForInRow en ajoutant comme prévus de nouveaux cas.

Les données de test se compose d'une ordinateur avec un mode (facile ou difficile) et de l'état de la structure de donnée , c'est à dire de la grille de jeux. Dans le rapport l'ensemble des tests se feront a l'aide d'une IA en mode difficile, l'IA facile ayant le même comportement avec des stratégies en moins .Certains testes sont quand même présent dans \texttt{Junit} sur l'ordinateur en mode facile et des grilles non conventionnelles, de même la validité des accesseurs a été testé, Nous avons choisis ici de présenter que les résultats les plus  significatifs.

L'ordinateur ne possède aucune aléatoire si bien qu'il est possible de calculer chacun de ses coups en connaissant l'état de sa grille.

\subsubsection{Les tests}
Tout d'abord nous avons vérifier que \texttt{initialize(DataStructure grid, int difficulty)} initialise correctement l'objet \texttt{IaForInRow}, C'est à dire que \texttt{CpuGrid} soit le même Objet que la grille \texttt{grid} passer en référence, et que le mode de difficulté soit correcte.

\begin{verbatim}
//Standard grid and easy difficulty
ia1.initialize(grid, mode1);
[...]
assertNotNull(ia1.getCpuGrid());
assertNotNull(ia1.getWidth());
assertNotNull(ia1.getHeight());
assertNotNull(ia1.getMode());
assertSame(ia1.getCpuGrid(),grid);
assertEquals(7,ia1.getWidth());
assertEquals(6,ia1.getHeight());
assertEquals(1,ia1.getMode());
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{nmfigempty}
  \caption{\texttt{Grille vide}}
\end{center}
\end{figure}

La grille est vide nous devons donc vérifier que l'ordinateur ne met pas encore en place de stratégie donc que 
\texttt{playable[]} est entièrement à 0 et que donc par défaut l'ordinateur joue au centre de la grille.


\begin{verbatim}
int Ia2Played = ia2.play(rule);
assertNotNull(Ia2Played);
assertTrue(0 <= Ia2Played && Ia2Played < grid.getWidth());
assertEquals(3, Ia2Played);
int[] playable2 = ia2.getPlayable();
for ( int i =0 ; i<ia2.getCpuGrid().getWidth();i++)
assertEquals(0,playable2[i]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{nmfigfull}
  \caption{\texttt{Grille pleine}}
\end{center}
\end{figure}

La grille étant pleine l'ordinateur ne peut donc pas jouer elle doit retourner le code d'erreur -1.

\begin{verbatim}
 int Ia2PlayedFullGrid = ia2.play(rule);
 assertFalse(0 <= Ia2PlayedFullGrid && Ia2PlayedFullGrid < grid.getWidth());
 assertEquals(-1, Ia2PlayedFullGrid);
\end{verbatim}

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{nmfigwin}
  \caption{\texttt{Grille avec coup gagnant}}
\end{center}
\end{figure}

Il y une la possibilité pour l'ordinateur de gagner, il doit donc repérer la colonne qui permet de gagner en y mettant le code \texttt{playable} à 3 et y jouer.

\begin{verbatim}
 int Ia4PlayedForWin = ia4.play(rule);
assertNotNull(Ia4PlayedForWin);
assertTrue(0 <= Ia4PlayedForWin && Ia4PlayedForWin < grid_null.getWidth());
assertEquals(6, Ia4PlayedForWin);
int[] playable4 = ia4.getPlayable();
for ( int i =0 ; i<ia4.getCpuGrid().getWidth();i++)
   if ( i == 6)
assertEquals(3,playable4[i]);
   else
assertEquals(0,playable4[i]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable3}
  \caption{\texttt{Autre cas de coup gagnant}}
\end{center}
\end{figure}

L'ordinateur peut à nouveau gagner en jouant en 2 et
donc il doit le faire avec \texttt{playable[2]=2}.

\begin{verbatim}
 int Ia2Playedfig4 = ia2.play(rule);
int[] playable7 = ia2.getPlayable();
assertEquals(2 , Ia2Playedfig4);
assertEquals(3, playable7[2]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable10}
  \caption{\texttt{Colonne injouable}}
\end{center}
\end{figure}

Si l'ordinateur joue sur la colonne 4, alors au prochain coups l'autre joueur 
pourra gagner avec une diagonale. L'ordinateur devra donc avoir
\texttt{playable[4]=1} qui correspond a un placement de pions qui fait gagner l'adversaire
 et jouer sur une autre case, ici nous savons qu'il va jouer en 2
dut au fait du caractère non aléatoire de l'ordinateur.

\begin{verbatim}
 int Ia2Playedfig2 = ia2.play(rule);
int[] playable5 = ia2.getPlayable();
assertEquals(2 , Ia2Playedfig2);
assertEquals(1 , playable5[4]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable2}
  \caption{\texttt{Stratégie sur plusieur coups}}
\end{center}
\end{figure}

Si l'ordinateur joue en 2 cela permettra a l'autre joueur de bloquer 
un éventuel coup gagnant futur.l'ordinateur doit avoir \texttt{playable[2] = 2} ce qui est
 un code moins fort que 1 mais il ne doit pas y jouer tout de même dans la mesure du possibles, si
il doit choisir entre un \texttt{playable} à 1 ou 2 il choisira tout de même le code 2.

\begin{verbatim}
 int Ia2Playedfig3 = ia2.play(rule);
int[] playable6 = ia2.getPlayable();
assertEquals(3 , Ia2Playedfig3);
assertEquals(2, playable6[2]);
\end{verbatim}




\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable4}
  \caption{\texttt{Colonne injouable}}
\end{center}
\end{figure}

La colonne 1 est pleine donc l'ordinateur ne doit plus y jouer et  \texttt{playable[1] = 4}.
C'est le code qui interdit de jouer le plus fort si tout les colonnes sont a 4 il renvera un code d'erreur -1.
C'est le seul code de \texttt{playable}  ou il est totalement impossible de jouer dans la colonne marqué.


\begin{verbatim}
 int[] playable8 = ia2.getPlayable();
assertEquals(4, playable8[1]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{nmfig6}
  \caption{\texttt{Strategie sur plusieurs coup}}
\end{center}
\end{figure}

L'ordinateur doit remarquer qu'il peut gagner en deux coup il met donc \texttt{playable}
à 5 sur les cases offrant cette possibilité : \texttt{playable[2] =  5} et \texttt{playable[5] = 5}.
(  colonne 2 et 6 sur la grille ).Il prépare donc comme voulu sa stratégie sur 2 coups qu'il modifiera en 
fonction de du coup jouer par l'autre joueur.

\begin{verbatim}
 int Ia2Playedfig6 = ia2.play(rule);
int[] playable9 = ia2.getPlayable();
assertEquals(5 , Ia2Playedfig6);
assertEquals(5, playable9[1]);
assertEquals(5, playable9[5]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable1}
  \caption{\texttt{Stratégie de blocage}}
\end{center}
\end{figure}
L'ordinateur peut aussi prévoir à l'avance les positions dangereuses des pions de l'autre joueur,
il mettra ainsi en place la tactique \texttt{playable} 6 dans les colonnes qui couperont les alignements 
possibles des pions adverses.Dans ce cas la \texttt{playable[1] = 6} et \texttt{playable[4] = 6}.Il jouera donc dans
l'une de ces deux colonnes , ici la colonne 4.

\begin{verbatim}
int Ia2Playedfig7 = ia2.play(rule);
int[] playable10 = ia2.getPlayable();
assertEquals(4 , Ia2Playedfig7);
assertEquals(6, playable10[0]);
assertEquals(6, playable10[4]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable6}
  \caption{\texttt{Coup Obligatoire}}
\end{center}
\end{figure}

L'ordinateur est obliger de jouer en colonne 4 sous peine de voir l'autre joueur gagner au prochain coup.
Nous devons donc avoir \texttt{playable[4]=6} qui est le code prioritaire pour les coups à jouer. 

\begin{verbatim}
 int Ia2Playedfig8 = ia2.play(rule);
int[] playablefig8 = ia2.getPlayable();
assertEquals(4 , Ia2Playedfig8);
assertEquals(6, playablefig8[4]);
\end{verbatim}


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{nmfig9}
  \caption{\texttt{Non blocage du jeu}}
\end{center}
\end{figure}
Il peut arriver que l'ordinateur n'est pas le choix et doit jouer dans une colonne même si son
\texttt{playble} est à 1  c'est a dire que jouer ce coup fera gagner l'autre joueur, nous devons vérifier que l'ordinateur le fera quand même sous peine de bloquer la partie.Donc ici \texttt{played[3]=1} , mais l'ordinateur joue en 3 (4ème colonne) et fait ainsi gagner l'autre joueur.

\subsubsection{Conclusion}
%%%%%%%%bugs%%%%%%%%

Ces tests nous ont permis de révéler de nombreux bugs liée aux comportements des IA. Tout d'abord sur les stratégies de \texttt{playable[]} qui n'était pas toujours juste par rapport à l'état actuel de la grille,et aussi le façon de jouer des IA ne correspondait pas toujours à ce qui était attendut dut au fait des priorités des \texttt{playable}.

Pour chaque état de la grille ils nous étaient possible a l'aide de l'algorithme de connaitre l'état de \texttt{playable[]} et le coup que doit jouer l'IA ainsi nous avons corriger les moteurs d'IA pour qu'ils nous donnes exactement les résultats escomptés dans les cas typiques ci-dessus.

%%%%%%%cfa%%%%%%
L'ensemble des testes ci-dessus permmettent de couvrir intégralement les arrêtes de l'Automate de flow de contrôle de l'IA en mode difficile ( et donc de l'IA facil qui est une sous partie), nous sommes donc dans le cas d'une couverture TER2, la complexité du CFA ne nous permet pas d'obtenit des TER supérieur sans une démultiplication des tests.

