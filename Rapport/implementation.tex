% -*- mode: latex; coding: latin-1-unix -*- %

\section{Implementation}

\subsection{DataStructure}
\subsubsection{Matrice}
\begin{verbatim}
   private int[][] matrix;
   private int height;
   private int width;
\end{verbatim}
Nous avons choisi d'utiliser une matrice pour modéliser une grille de
Puissance 4. Ce sera un tableau d'entiers. Afin de faire moins de
calculs nous avons choisi de stocker la hauteur ainsi que la largeur
de la matrice dans deux variables distinctes \texttt{height} respectivement \texttt{width}.

\begin{verbatim}
   public DataStructure(int height, int width);
\end{verbatim}
Le constructeur va prendre deux entiers en paramètres. Ce constructeur
va vérifier si ces entiers sont valides, autrement dit si ils ne sont
pas négatifs ou nuls.

\begin{verbatim}
   public int getHeight();
   public int getWidth();
   public int getValue(int i, int j);
   public boolean setValue(int i, int j, int color);
\end{verbatim}
Nous avons préféré mettre nos variables (\texttt{matrix}, \texttt{height} et \texttt{width}) en
private pour éviter toutes modifications inattendues de notre
matrice. d'où l'existence de ces accesseurs. Nous n'avons pas fait
d'accesseur direct à la matrice, autrement dit qui retournerait notre
matrice, toujours dans le soucis de modifications inattendues.

La méthode \texttt{setValue} va modifier notre matrice en respectant la
contrainte disant que \texttt{i} et \texttt{j} doivent etre compris entre 0 et respectivement
\texttt{height} et \texttt{width}.

Nous n'avons pas mis de restriction sur color, etant donné que la
structure de données ne gère pas les règles du jeu, elle ne sait pas
de quoi il s'agit exactement.

Cette méthode retourne un booléen qui renvoie \texttt{true}
respectivement \texttt{false} si la modification a pu être apporté ou pas.

\begin{verbatim}
   public void reset_matrix();
   public void print();
\end{verbatim}
La méthode \texttt{reset\_matrix} va, comme son nom l'indique, faire un
simple reset de la matrice.

La méthode \texttt{print} va elle afficher la matrice.


\subsubsection{Tests de la matrice}

Nos différentes classes de test dérivent de \textbf{junit.framework.TestCase}. Elles ont une méthode setUp(), exécutée avant chaque méthode de test, pour initialiser les tests et une méthode tearDown(), exécutée après chaque méthode de test , pour relâcher les données.\newline
Les méthodes de test n'attendent pas de paramètres et retournent \textbf{void}. Leur nom commence par \textbf{testXXX}.\newline
A l'intérieur des méthodes de test, on effectue les actions de test souhaitées, et on
vérifie qu'elles se passent correctement en utilisant des méthodes \textbf{assertXXX}.\newline


Ces tests consistent à s'assurer que la structure de données, qui
représente notre grille de Puissance 4, est robuste.\newline

Le premier test envisagé est d'instancier une \texttt{DataStructure} 6$\times$7
correspondant à la grille classique. Tout en vérifiant par les
accesseurs que les dimensions de la matrice sont celles attendues.

On réalise ensuite des tests aux limites sur notre structure de
données, par exemple 0$\times$0. Pour continuer sur quelques tests
aléatoires 100$\times$100.

Nous allons tester des ajouts de valeurs prises de manière aléatoire
mais qui restent valides. Et vérifier le comportement de \texttt{setValue} aux bornes. Donc en valeur
\texttt{i} et \texttt{j} négatives ou supérieures à \texttt{height} et
à \texttt{width}.

Exemple :\newline

\textbf{testAddingMoreThan42Values()} : \newline
Mettre une valeur à une position de la grille s'écrit : \textbf{matrix.setValue(i, j, c)}. Cette action doit retourner un booléen \textbf{true}, ce qui est testé par l'instruction :\newline
\begin{center}
\textbf{assertTrue(matrix.setValue(i, j, c));}
\begin{center}

Une fois toutes les cases de la grille remplies, le test d'ajout ne doit plus passer, ce qui s'écrit : \newline
\begin{center}
\textbf{assertFalse(matrix.setValue(i, j, c));}
\end{center} 

Un \textbf{test aux limitex} a été mis en place dans cette méthode : En plus de tester la possibilité que toutes les cases de la grille soient remplies, nous avons testé le rajout de valeurs à des positions \textit{hors limite}.\newline
Exemple :\newline
\textbf{assertFalse("Test aux limites : limite inf", matrix.setValue(-1, -1, 1));}\newline
\textbf{assertFalse("Test aux limites : limite sup", matrix.setValue(6, 0, 0));}\newline


 





\subsection{Player}
\texttt{Player} est une interface permettant de basculer facilement entre un
\texttt{HumanPlayer} et un \texttt{CpuPlayer}. Nous reverrons cette partie dans le \texttt{GameEngine}.

\subsubsection{HumanPlayer}
\begin{verbatim}
    private int currently_played;
\end{verbatim}
Sert a mémoriser la position que le joueur a choisi.

\begin{verbatim}
    public int play(DataStructure grid, GUI gui);
\end{verbatim}
Cette méthode va attendre que le joueur face son choix à travers
l'interface graphique. Elle récupère aussi bien une position jouée
qu'un reset de la grille. Cette méthode retourne la position choisit
par le joueur mais ne vérifie pas si elle est correcte. Cela s'effectue
plus loin au moment du \texttt{GameEngine}.

\subsubsection{CpuPlayer}
\begin{verbatim}
    private int mode;
    private int currently_played;
    private Rules rule;
\end{verbatim}
La première variable va stocker le mode, 0 pour deux humains, 1 pour
un ordinateur facile et 2 pour un ordinateur difficile.

La seconde variable, \texttt{currently\_played}, stocke la position
jouée par le joueur (humain ou ordinateur).

La troisième variable, \texttt{rule}, va stocker les règles du
jeu. Cela est utile pour l'ordinateur, afin de bien respecter les
règles du jeu lorsqu'il effectue un choix. Nous reverrons plus en
détail cette partie dans la classe \texttt{IaFourInARow} qui
implémente l'intelligence artificielle.

\begin{verbatim}
    public CpuPlayer(int mode, Rules rule);
    public int play(DataStructure grid, GUI gui);
\end{verbatim}

Notre première méthode est un constructeur. Elle attribut donc un \texttt{mode}
au CpuPlayer mais aussi les règles a utiliser (\texttt{Rules}).

Notre seconde méthode, \texttt{play}, similaire à celle de
HumanPlayer. Elle va quand a elle vraiment instancier l'intelligence
artificielle en fonction du mode choisit. Cela se fait à l'aide des lignes 21-22 :
\begin{verbatim}
     Cpu cpu1 = new IaFourInARow();
     cpu1.initialize(grid, mode);
\end{verbatim}
Si on veut utiliser une autre intelligence artificielle, il suffirait
de créer une nouvelle classe qui implémente \texttt{Cpu} et qui fonctionne
globalement comme l'IA actuelle. Notre Intelligence artificielle est
donc totallement indépendante du reste du programme et peut être
changé facilement.

\subsubsection{Jeux de test}
TODO

\subsection{Cpu}
\texttt{Cpu} est une interface. le fait d'avoir créé une interface va nous
permettre de pouvoir implémenter de nouvelles IA sans modifier plus
d'une ligne du code actuel.

\subsubsection{IaFourInARow}
Pour ce qui concerne l'intelligence artificielle, nous avons choisi
d'en implémenter une séquentielle. Il n'y aucune part
d'aléatoire. Cette IA n'implémente pas la stratégie gagnante. Nous nous sommes
renseigné et il faudrait implémenté un arbre faisant intervenir des
statistiques de meilleurs coups a jouer. cela ne semble pas évident au
premier abord à implémenter, c'est pourquoi nous avons implémenté une
IA maison qui donne des résultats assez satisfaisant car non triviale.

cependant si on veut implémentr la stratégie gagnante cela est
possible en créant une classe qui implémente l'interface \texttt{Cpu}
et qui respecte le fonctionnement de l'IA actuelle qui est décrit ci-après.

\begin{verbatim}
    private int mode;
    private DataStructure cpugrid;
    private int[] playable;
\end{verbatim}
Comme toujours le \texttt{mode} stocke la difficulté de l'IA, 1 pour
facile, 2 pour difficile.

\texttt{cpugrid} n'est pas une copie de la grille, mais un pointeur sur
la grille, donc si on modifie cpugrid on modifie aussi la grille de
puissance 4. Nous avons fait ce choix pour éviter de recopier la
grille à chaque fois, mais cela ajoute de la contrainte de ne pas
modifier la grille lors du calcul de notre stratégie.

La variable \texttt{playable} va etre de la taille de
\texttt{width}. Elle va servir pour déterminer quelle colonne jouer ou
quelle colonne ne pas jouer. tout cela se fait à l'aide d'un codage
simple.\newpage

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable0}
  \caption{\texttt{playable[i] = 0}}
\end{center}
\end{figure}
Dans ce cas, tous les playable[i] sont égaux à 0. autrement dit on
peut jouer sur n'importe quelle case. Seulement notre intelligence
artificielle choisiera de jouer au centre du jeu, car la probabilité
de gagner lors qu'on joue au centre est supérieure aux autres (par
exemple si on joue sur les cotés).

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable10}
  \caption{\texttt{playable[i] = 1}}
\end{center}
\end{figure}
Si l'ordinateur joue sur la colonne 4, alors au prochain coups le
joueur humain pourra gagner avec une diagonale. Par conséquent
\texttt{playable[4]=1}. Ce code signifie que si l'ordinateur joue sur
cette colonne alors cela peut faire gagner le joueur humain.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable2}
  \caption{\texttt{playable[i] = 2}}
\end{center}
\end{figure}
Dans ce cas \texttt{playable[2] = 2}. Autrement dit, si l'ordinateur
joue sur la colonne deux, le joueur humain pourra le bloquer.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable3}
  \caption{\texttt{playable[i] = 3}}
\end{center}
\end{figure}
Dans ce cas \texttt{playable[2] = 3}. Par conséquent l'ordinateur peut
gagner ua prochain coups, et jouera la position 2.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable4}
  \caption{\texttt{playable[i] = 4}}
\end{center}
\end{figure}
La colonne 1 est pleine donc \texttt{playable[1] = 4}. L'ordinateur
prend conscience qu'il ne pourra pas placer de jetons dans cette
colonne.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable5}
  \caption{\texttt{playable[i] = 5}}
\end{center}
\end{figure}
A ce moment du jeu, l'ordinateur remarque qu'il peut gagner en
ajoutant 2 pions. Par conséquent il va marquer \texttt{playable[4] =
  5} et \texttt{playable[5] = 5}.


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable1}
  \caption{\texttt{playable[i] = 6}}
\end{center}
\end{figure}
Dans ce cas la \texttt{playable[1] = 6} et \texttt{playable[4] = 6}. Et tous
les autres cas \texttt{playable[i]=0}. L'ordinateur va bloquer la
possibilité de mouvement de l'humain.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.2]{playable6}
  \caption{\texttt{playable[i] = 6}}
\end{center}
\end{figure}
Si le joueur humain place un pion dans la colonne 4 il remportera la
victoire. Pour eviter de perdre aussi facilement on met
\texttt{playable[4]=6}, et l'ordinateur va bloquer la victoire du
joeur humain.

\begin{verbatim}
    private Rules rule;
    private int height;
    private int width;
\end{verbatim}
La première vriable va contenir les règles du jeux qui sont utilisées,
dans notre cas ce sera pour le Puissance 4. Les deux variables
suivantes contiennent la hauteur, respectivement la largeur de notre \texttt{cpugrid}.

\begin{verbatim}
    private void strategy();
    private void breakStrategy();
    private void noPlayable();
    private void winningPlayable();
    private void fillPlayable();
\end{verbatim}
La méthode \texttt{strategie()} va parcourir la grille et calculer les
positions que l'ordinateur peut jouer pour pouvoir gagner en deux
coups. une fois qu'elle a repérer les colonnes et remplie en
conséquence \texttt{playable[i]}. La méthode suivante,
\texttt{breakStrategy()} va parcourir la grille et va regarder si
lorsque l'ordinateur joue un coup, alors cela permettra a l'humain de
la bloquer alors qu'avant il ne le pouvait pas. (pour plus de détails
voir les captures d'écran précédemment). Dans ce cas
\texttt{playable[i] = 5}.

La méthode \texttt{noPlayable} a un double usage. tout d'abord elle
regarde si le joueur humain peut gagner au prochain coups. Dans ce cas
elle marque \texttt{playable[i] = 6} (i correspondant à la
colonne). Mais elle va aussi vérifier si en jouant une colonne cela
permet à l'humain, au coups d'après, de gagner la partie. Dans ce cas
\texttt{playable[i] = 1}.

Pour \texttt{winningPlayable()}, on regarde si l'ordinateur peut
gagner au prochain coups, et on marque la colonne correspondante par 3
autrement dit \texttt{playable[i] = 3}.

La méthode \texttt{fillPlayable()} quand a elle initialise
\texttt{playable[i] = 0} pour les colonnes ou on peut encore
jouer. Pour ce qui concerne les colonnes pleines, alors
\texttt{fillPlayable()} va mettre \texttt{playable[i]=4}.

\begin{verbatim}
    public void initialize(DataStructure grid, int difficulty);
    public int play(Rules new_rule);
\end{verbatim}
La méthode \texttt{initialize()} nést pas un constructeur, mais comme
son nom l'indique, elle va initialiser le \texttt{Cpu}. Quand à la
méthode \texttt{play()} elle va vérifier selon le \texttt{mode},
autrement dit la \texttt{difficulty}, quelle IA appeler.

\begin{verbatim}
    public int perfectCpu();
    public int easyCpu();
\end{verbatim}
Ces deux méthodes sont très similaires, à la différence que le
\texttt{perfectCpu()} appelle les méthodes \texttt{breakStrategy()} et
\texttt{strategy()}, ce que ne fais pas la méthode
\texttt{easyCpu()}. Le mode \texttt{easyCpu} est moins agressif que le
mode \texttt{perfectCpu()}, qui en passant n'est pas parfait ;-)\newline
Dans notre méthode \texttt{perfectCpu()} on commence par remplir la
grille avec \texttt{fillGrid()} et continue par vérifier si
on peut gagner au prochain coup à l'aide de la méthode
\texttt{winningPlayable()}. Si il y a une position gagnante alors on
retourne le numéro de la colonne. Sinon on regarde si le joueur humain
peut gagner au prochain coups, ou si jouer une certaine colonne peut
le faire gagner. Tout cela à l'aide de la méthode
\texttt{noPlayable()}.


Si on est dans le \texttt{perfectCpu()} alors on établie une
stratégie. Pour cela on évite de jouer une colonne ou l'humain
pourrait nous bloquer par la suite, avec la méthode
\texttt{breakStrategy()}. Ensuite on essaie d'établir une stratégie,
si on a 2 jetons alignés, alors on va essayer dén aligner 2 de plus
pour faire un 4 à la suite, à l'aide de la méthode
\texttt{strategy()}. Cela ne se fait que dans la méthode \texttt{perfectCpu()}


On continue, peu importe la méthode \texttt{perfectCpu()} ou
\texttt{easyCpu()}, on regarde si on a autre chose que des 0, 1 et 2
dans \texttt{playable[i]}, et dans ce cas on remplit les colonnes du
milieu de la grille. Sinon dans l'ordre des priorités pour
\texttt{playable[i]} l'ordinateur joue de cette manière : \texttt{3 -
  6 -  5 -  0 -  2 -  1}.

\subsubsection{Jeux de test}

TODO

\subsection{Rules}

\texttt{Rules} est une interface. Cela nous permet d'implémenter de
nouvelles règles. Ca peut être utile si on veut transformer notre
Puissance 4 en Morpion, ou si on veut faire un Puissance 5 ...

\subsubsection{FourInARow}
Cette classe implémente \texttt{Rules}.

\begin{verbatim}
    public boolean checkDiag(int i, int j, int color, DataStructure grid);
    public boolean checkCol(int i, int j, int color, DataStructure grid);
    public boolean checkLine(int i, int j, int color, DataStructure grid);
    public boolean isComplete(DataStructure grid);
    public boolean checkPlay(int play, DataStructure grid);
    public void greyOut(GUI app, DataStructure grid);
\end{verbatim}

\texttt{checkDiag()} retourne \texttt{true} si il existe un alignement
de 4 jetons d'une même couleur en diagonale. Il retourne
\texttt{false} sinon. \texttt{checkCol()} retourne \texttt{true} si il existe un alignement
de 4 jetons d'une même couleur en colonne. Il retourne
\texttt{false} sinon. \texttt{checkLine()} retourne \texttt{true} si il existe un alignement
de 4 jetons d'une même couleur en Ligne. Il retourne
\texttt{false} sinon. \texttt{isComplete()} va faire appel aux trois
méthodes précédentes afin de vérifier si il y a un gagnant. Auquel cas
cette méthode retourne \texttt{true}, sinon elle renvoie
\texttt{false}. La méthode \texttt{checkPlay()} vérifie que la
position passée en argument est jouable, elle renvoie \texttt{true} si
cést jouable, et \texttt{false} sinon.

La dernière méthode, \texttt{greyOut()}, va quand a elle griser les bouttons des colonnes
pleines correspondantes.

\subsubsection{Tests de FourInARow}
TODO

\subsection{GameEngine}
\subsubsection{Implémentation}
\begin{verbatim}
    private DataStructure grid;
    private boolean current_player;
    private int currently_played;
    private GUI app;
    private int mode;
    private Rules rule;
    private Player player1;
    private Player player2;
    private int counter;
\end{verbatim}
La variable \texttt{grid} contient la grille du
jeu. \texttt{current\_player} peut obtenir deux valeurs, 0 qui
correspond au joueur 1, et 1 qui correspond au joueur
2. \texttt{currently\_played} contient le coup joué (une position ou un
reset). \texttt{app} contient l'interface graphique. \texttt{mode}
contient le mode de jeu. \texttt{rule} contient les règles du
jeu. \texttt{playerX} contient le joueur, qui peut etre humain ou
artificiel. \texttt{counter} contient le nombre de coups joué, cela
nous permet de déterminer si il y a un match nul.

\begin{verbatim}
    public GameEngine();
    public void initMode(int my_mode);
    public void close();
    public void start();
    public void resetGrid();
    public void updatePlay();

    private void updateGrid();
\end{verbatim}
Le constructeur initialise l'interface graphique, la grille (avec une
taille que l'on peut modifier) et les règles du jeu. La méthode
\texttt{initMode()} initialise les joueurs, la variable
\texttt{my\_mode} et reset le \texttt{counter}. La méthode
\texttt{close()} quand à elle ferme l'interface graphique. Cette
méthode n'est appelée que par le \texttt{Main()}.

La méthode \texttt{start()} s'occupe de lancer le jeu. il aura été
initialisé par les autres méthodes qui la précède.\newline
La boucle \texttt{while((!rule.isComplete(grid)) \&\& (counter <} 
\texttt{grid.getWidth() * grid.getHeight()))} va faire en sorte que le jeu
ne se termine pas tant qu'il n'y a pas de gagnant ou que la grille
n'est pas pleine. Il faut savoir que l'utilisateur peut arrêter le
programme a tout moment a l'aide de l'interface graphique.

Cette méthode fiat jouer a tour de rôle le joueur 1 et le joueur
2. C'est la méthode \texttt{start()} qui va interpréter le choix du
joueur, autrement dit, si \texttt{currently\_played = -2} ca implique
qu'il faut reset la grille.

A chaque tour de boucle on incrémente la variable \texttt{counter} de
un si la position jouée est valide. Par la suite on met à jour la
grille à l'aide de la méthode \texttt{updatePlay()} et on grise les
bouttons dont les colonnes sont pleines à l'aide de la méthode
\texttt{rule.greyOut()}.

Une fois la boucle terminée, autrement dit, lorsque le jeu est terminé
on vérifie qui a gagné et on l'affiche à l'aide de la méthode \texttt{gameEnded()}.

La méthode \texttt{resetGrid()} s'occupe d'initialiser la
\texttt{grid} avec des 0, elle fait en sorte de ne aps re-faire
appelle à elle avec la méthode \texttt{app.setReset(false)} et
réinitialise tous les boutons avec la méthode
\texttt{app.enableAllButton()}. Il faut aussi réinitialiser le
\texttt{counter} et mettre à jour l'affichage graphique.

La méthode \texttt{updatePlay()}, va quand à elle, re-vérifier si la
position jouée est valide puis va mettre à jour la grille, et enfin
met à jour l'affichage.

La méthode \texttt{updateGrid()} va mettre à jour la grille, autrement
cést elle qu iva générer la gravité, si on peut dire.

\subsubsection{Tests du GameEngine}
TODO

\subsection{Main et Menu}
Le \texttt{Main()} va instancier le \texttt{GameEngine} mais aussi le
menu de départ. cést le \texttt{Main()} qui va dire au
\texttt{Gameengine} de démarrer le jeu avec l'appel à la méthode
\texttt{g.start()}. Le \texttt{Main()} fait au \texttt{GameEngine}
instancier les joueurs avec l'appel à la méthode
\texttt{g.initMode(my\_menu.choice)}.\newline
\newline
Pour ce qui concerne le menu, on aurait pu l'intégrer dans l'interface
graphique, mais nous n'avions pas assez de temps pour faire cette
petite modification, et nous avons préféré passer aux tests directement.

\subsection{GUI}

\texttt{GUI} est une interface, cela nous permettra, au besoin, de branher une autre interface graphique à notre application.

\subsubsection{GuiOwn}
Cette classe, implémente \texttt{GUI}. 
\begin{verbatim}
    public int choice;
    public boolean played;
    public boolean reset;
    public boolean game_ended;
\end{verbatim}
La première variable \texttt{choice} contient la colonne sélectionné par le joueur humain. La seconde variable \texttt{played} est a \texttt{true} lorsqu'un joueur a choisi une colonne et est a \texttt{false} sinon. Il en est de même pour \texttt{reset} et pour \texttt{game\_ended}. A savoir que \texttt{reset} concerne le reset de la grille et \texttt{game\_ended} dit si le jeu est terminé ou non.

\begin{verbatim}
    public abstract void initGui(DataStructure grid);
\end{verbatim}
Cette méthode initialise l'interface grapique en créant autant de colonne et de ligne que la matrice en a.

\begin{verbatim}
    public abstract void updateScreen(DataStructure my_grid);
\end{verbatim}
\texttt{updateScreen} met a jour l'affichage de la grille.

\begin{verbatim}
    public abstract void gameEnded(boolean winner);
    public abstract void gameEnded();
\end{verbatim}
La première méthode affichage le nom du joueur dans l'interface graphique, et la seconde affiche Match nul.

\begin{verbatim}
    public abstract void greyAllButton();
\end{verbatim}
Cette méthode grise tous les bouttons qui permettent de choisir les colonnes mais aussi de faire un reset de la grille. Elle est utilisé lorsque le jeu est terminé.

\begin{verbatim}
    public abstract void enableAllButton();
\end{verbatim}
Cette méthode rend tous les bouttons correspondant aux colonnes non-grisés. Elle est utilisé lors d'un reset.

\begin{verbatim}
    public abstract void greyButton(int num);
\end{verbatim}
\texttt{greyButton()} grise le boutton de la colonne correspondante à num.

\begin{verbatim}
    public void setSize(int i, int j);
    public void setLocation(int i, int j);
    public void show();
    public abstract void dispose();
\end{verbatim}
La première méthode permet de définir la taille de la fenêtre de jeu. La seconde sert à définir la position de la fenêtre par défaut. La troisième est une méthode définit dans les librairies de \texttt{Swing} qui permet d'afficher l'interface graphique. Quand à la dernière méthode, elle permet de d'afficher/fermer une fenêtre. La méthode \texttt{dispose()} est aussi définit dans els librairies de \texttt{Swing}.

\begin{verbatim}
    public boolean getPlayed();
    public int getChoice();
    public void setPlayed(boolean played);
    public boolean getReset();
    public void setReset(boolean reset);
\end{verbatim}
Ces trois méthodes sont de simples accesseurs aux variables correspondantes.
