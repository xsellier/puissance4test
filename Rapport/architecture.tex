

\section{Architecture}

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.5]{premiere_architecture}
  \caption{\texttt{Notre première architecture}}
\end{center}
\end{figure}

Nous allons décrire ici les différents modules imaginés pour répondre aux attentes formulées dans la partie spécification.\newline

\subsection{Structure de données}

Nous implémenterons une classe contenant un tableau d'entiers et les différentes méthodes nécessaires aux accès en écriture et lecture sur celui-ci. Ainsi, on doit pouvoir instancier un tableau de dimensions variables, initialiser ses valeurs et les modifier. Le tableau doit également pouvoir être réinitialisé. Cette classe a pour but de représenter la grille et donc les coups joués par chaque joueur au long de la partie. On représentera une case vide par un entier nul à la position correspondante. Un entier dont la valeur est à 1 représentera un coup joué par le joueur 1, même chose pour le joueur 2.\newline
C'est ce module qui va permettre au joueur ordinateur de connaître les possibilités de jeu à chaque tour (coups jouables). C'est grâce à cette représentation également que l'on saura si la partie est terminée ou non. Enfin, l'interface sera mise à jour à chaque tour en fonction de ce tableau, ce qui évitera des possibilités de confusion entre les deux entités.\newline

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.5]{diagrammeDeClasseDataStructure}
  \caption{\texttt{Illustration des connexions de la structure de données}}
\end{center}
\end{figure}

\subsection{Joueurs}

Il sera nécessaire d'implémenter 2 classes différentes pour les 2 types de joueurs. Cependant, certaines méthodes ou variables étant communes à ces entités on prévoiera une interface regroupant les méthodes nécessaires au jeu et appelées quelque soit le type de joueur. Ceci permettra au module en charge du déroulement du jeu de faire abstraction de la configuration choisie, et donc de diminuer le volume de code.


\subsubsection{Humain}

Le joueur humain aura une connexion étroite avec l'interface choisie. En effet, jouer un coup reviendra à interroger l'utilisateur via cette interface. Cette classe sera donc relativement peu volumineuse et d'une complexité faible.




\subsubsection{Ordinateur}

L'entité représentant le joueur artificiel sera plus importante. On devra pourvoir choisir entre 2 niveaux de difficultés, ce qui se traduira par une instanciation selon un paramètre particulier, comme un entier ou un boolén. Ainsi, la classe représentant ce type de joueur contiendra des méthodes différentes et correspondant chacune à ce niveau et donc paramètre choisi. On choisira premièrement un algorithme simple représentant une stratégie triviale (exemple: jouer la même colonne ou une colonne voisine de  celle choisie par le joueur 1 précédemment), puis on cherchera à implémenter un algorithme plus 'intelligent' permettant au joueur humain de se confronter à une difficulté de jeu élevée. On se rapprochera d'une stratégie gagnante pour le joueur-ordinateur.


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.5]{diagrammeDeClassePlayers}
  \caption{\texttt{Interactions des joueurs}}
\end{center}
\end{figure}

\subsection{Règles}

Nous avons choisi d'implémenter un module destiné à l'application des règles tout au long de la partie. De manière plus spécifique, nous nous intéressons ici à la detection d'une situation incorrecte, d'une situation de terminaison ou bien du simple déroulement d'un coup joué.\newline

\begin{itemize}
\item Situation incorrecte \newline
La principale situation incorrecte dans notre système correspond au cas où un joueur tente d'ajouter un jeton dans une colonne déjà pleine. Le module en question contiendra les méthodes nécessaires à la detection de ce type de coup, méthodes que l'on utilisera alors pour avertir l'utilisateur de cette interdiction.\newline\newline

\item Situation de terminaison \newline
Une situation de terminaison se produit dans deux cas :\newline
Premièrement, un joueur aligne 4 pions dans la grille.\newline
Deuxièmement, la grille est remplie.\newline
De la même manière, on souhaitera que ces évènements soient détectés et traités en conséquence. C'est à dire, information de l'utilisateur et terminaison éventuelle du programme.\newline\newline


\item Déroulement d'un coup joué \newline
Lorsqu'un joueur communique son choix pour le coup en cours, le tableau d'entiers doit être modifié en conséquence. Nous avons décidé d'affecter cette tâche à ce module, qui sera donc en étroite corrélation avec la structure de données. Pour effectuer cette modification, la méthode correspondante aura connaissance du numéro du joueur en cours et la colonne choisie par ce joueur. L'action sera alors traduite par une affectation en accord avec les méthodes de la structure de données.\newline
\end{itemize}

L'ensemble de ces outils permettront au moteur de jeu décrit ci-dessous d'assurer le bon déroulement du jeu et donc du programme.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.5]{diagrammeDeClasseRules}
  \caption{\texttt{Illustration des interactions du module de règles de jeu}}
\end{center}
\end{figure}

\subsection{Moteur de jeu}

Le moteur de jeu sera le coeur de notre programme dans le sens où il mettra en rapport l'ensemble des entités du programme. Ainsi, il devra assurer le scénario standard suivant :

\begin{enumerate}
\item Phase d'initialisation
\item Phase de jeu (a)
\item Phase de modification (b)
\item Phase de communication (c)
\item Terminaison ou nouvelle partie
\end{enumerate}

La phase d'initialisation correspond à la création et au lancement de chacun des modules cités dans cette section: une grille de dimension choisie sera initialisée, les joueurs seront instanciés conformément au choix initial de l'utilisateur, l'interface utilisateur sera lancée au besoin, une instance du module de règles sera créée.\newline\newline

La phase de jeu correspond à l'ordonnancement des coups des joueurs. Tour à tour, le moteur de jeu consultera le joueur concerné et lui demandera de fournir le numéro de colonne qu'il souhaite jouer, qu'il soit humain ou ordinateur.\newline\newline

La phase de modification permettra de traduire ce choix en une consultation du module de règles et modification de la grille en conséquence.\newline\newline

La phase de communication représentera la notification au joueur via l'interface de la configuration actuelle du jeu. Ainsi, dans le cas d'une interface graphique on mettra à jour l'affichage du panneau en fonction du nouvel état de la grille.\newline\newline

Ces trois dernières phases (a-b-c) seront répétées jusqu'à ce qu'une situation de terminaison apparaîsse.\newline\newline

Enfin, l'utilisateur choisira de terminer le programme ou de jouer une nouvelle partie. Le module de jeu sera donc capable de se réinitialiser pour revenir à une configuration initiale.\newline\newline

Chacune de ces phases sera représentée par une ou des méthodes contenue dans une classe dédiée.\newline


\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.5]{diagrammeDeClasseGameEngine}
  \caption{\texttt{Connexions du moteur de jeu}}
\end{center}
\end{figure}

\subsection{Composants annexes}

On trouvera d'autres classes d'importance mineure :\newline \newline 

Une classe main sera présente et permettra d'instancier le moteur de jeu au démarrage du programme en lui communiquant le choix de configuration de l'utilisateur. D'autres interfaces pourront être ajoutées pour augmenter la modularité du programme.\newline
Enfin, dans le cas d'une interface graphique, il sera nécessaire de représenter chaque position de la grille grâce à des éléments graphiques changeant de couleur. De la même manière, d'autres composants graphiques permetront à l'utilisateur de communiquer son choix quant au coup qu'il veut jouer. On trouvera également une zone graphique destinée à l'avertir de la terminaison de la partie.


\subsection{Tests d'intégration}

\paragraph{Moteur de jeu} - interaction avec les différents modules.

\bigskip
La classe GameEngine qui représente le moteur de jeu est centrale dans notre
application. C'est le point de connexion de la plupart de nos
modules. C'est cette classe qui va
instancier la structure de données, les joueurs, les règles du jeu ainsi
que l'interface graphique. On concentre donc nos efforts de test
d'intégration sur ces points de connexion. Les parties qui suivent
porteront donc sur des tests entre chaque module et le moteur du jeu.

\paragraph{Structure de données} - instanciation et modification(s)

\bigskip
\begin{itemize}

\item \texttt{Test d'instanciation correcte}\newline
Lors du lancement du jeu, le moteur va instancier la structure
de données. On teste donc l'instanciation en rentrant des valeurs
particulières pour la grille. On vérifie que l'objet créé a la taille demandée.

\bigskip
\item \texttt{Test d'instanciation incorrecte}\newline
Dans un soucis de robustesse, on teste le cas où une
grille de taille incorrecte est instanciée par le moteur de
jeu.

\item \texttt{Test de lecture/modification correcte}\newline
Lors d'une partie le moteur de jeu doit pouvoir lire et modifier
sans difficulté la grille. Nous devrons tester si les modifications
apportées par le moteur de jeu sont bien effectuées par la structure
de données.



\bigskip
\item \texttt{Test de lecture/modification incorrecte}\newline
Toujours dans un soucis de robustesse, la structure de données
doit pouvoir traiter les saisies incorrectes. \texttt{false}.
\end{itemize}

\paragraph{Joueurs} - instanciation et interaction

\bigskip
\begin{itemize}

\item \texttt{Test d'instanciation}\newline
Il n'y a pas d'erreur possible sur les paramètres du constructeur de
joueur car ce dernier n'admet pas de paramètres.
Le seul point qui doit être vérifié est le type de l'instance du
joueur.
\bigskip


\item \texttt{Tests d'interaction}\newline
Nous devons vérifier que les coups joués par l'ordinateur sont bien
ceux récupérés par le moteur du jeu. Il faut aussi vérifier que si
l'ordinateur renvoit une valeur impossible, par exemple une colonne
pleine, cela ne perturbe pas le fonctionnement du programme, mais
demande une nouvelle valeur à l'ordinateur.

\item \texttt{Test d'intégrité de la grille}\newline
On doit vérifier que la grille fournit à
l'ordinateur, corresponde a celle du moteur de
jeu. On doit donc vérifier que le passage en paramètre de la grille au joueur ne modifie pas cette dernière. 
\end{itemize}

\paragraph{Règles} - instanciation et utilisation

\bigskip
\begin{itemize}
\item Séquence de jeu\newline
On doit tester si l'alternance des coups entre les deux joueurs est correcte.
\bigskip

\item Intégrité de la grille\newline
Il faudra soumettre aux règles des grilles correcte et vérifier que la 
grille n'est pas modifiée. Dans le cas ou il y a un
gagnant nos règles devront nous le spécifier.
\bigskip

\item Condition de terminaison\newline
Les contitions de victoires ou match nul doivent être correctes. Ceci sera vérifié sur un nombre maximal de parties (manuellement ou automatiquement).
\bigskip


\item Utilisation incorrecte\newline
Nous espérons avoir un module robuste pour gérer les accès incorrects
fait par le moteur de jeu, mais aussi des grilles incorrectes. Avec
plusieurs gagnants, et encore une fois voir si nos règles valides ou
non ces grilles.
\end{itemize}

\paragraph{Modularité}

Il doit être possible d'implémenter une nouvelle interface ou un nouveau niveau de jeu en changeant une seule ligne de code.
Si un tel changement nécessite une modification plus vaste le test n'est pas considéré comme réussi.


