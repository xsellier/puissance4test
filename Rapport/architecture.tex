% -*- mode: latex; coding: latin-1-unix -*- %

\section{Architecture}
Nous allons décrire ici les différents modules imaginés pour répondre aux attentes formulées dans la partie spécification.\newline

\subsection{Structure de données}

Nous implémenterons une classe contenant un tableau d'entiers et les différentes méthodes nécessaires aux accès en écriture et lecture sur celui-ci. Ainsi, on doit pouvoir instancier un tableau de dimensions variables, initialiser ses valeurs et les modifier. Le tableau doit également pouvoir être réinitialisé. Cette classe a pour but de représenter la grille et donc les coups joués par chaque joueur au long de la partie. On représentera une case vide par un entier nul à la position correspondante. Un entier dont la valeur est à 1 représentera un coup joué par le joueur 1, même chose pour le joueur 2.\newline
C'est ce module qui va permettre au joueur ordinateur de connaître les possibilités de jeu à chaque tour (coups jouables). C'est grâce à cette représentation également que l'on saura si la partie est terminée ou non. Enfin, l'interface sera mise à jour à chaque tour en fonction de ce tableau, ce qui évitera des possibilités de confusion entre les deux entités.\newline

\subsection{Joueurs}

Il sera nécessaire d'implémenter 2 classes différentes pour les 2 types de joueurs. Cependant, certaines méthodes ou variables étant communes à ces entités on prévoiera une interface regroupant les méthodes nécessaires au jeu et appelées quelque soit le type de joueur. Ceci permettra au module en charge du déroulement du jeu de faire abstraction de la configuration choisie, et donc de diminuer le volume de code.

\subsubsection{Humain}

Le joueur humain aura une connexion étroite avec l'interface choisie. En effet, jouer un coup reviendra à interroger l'utilisateur via cette interface. Cette classe sera donc relativement peu volumineuse et d'une complexité faible.


\subsubsection{Ordinateur}

L'entité représentant le joueur artificiel sera plus importante. On devra pourvoir choisir entre 2 niveaux de difficultés, ce qui se traduira par une instanciation selon un paramètre particulier, comme un entier ou un boolén. Ainsi, la classe représentant ce type de joueur contiendra des méthodes différentes et correspondant chacune à ce niveau et donc paramètre choisi. On choisira premièrement un algorithme simple représentant une stratégie triviale (exemple: jouer la même colonne ou une colonne voisine de  celle choisie par le joueur 1 précédemment), puis on cherchera à implémenter un algorithme plus 'intelligent' permettant au joueur humain de se confronter à une difficulté de jeu élevée. On se rapprochera d'une stratégie gagnante pour le joueur-ordinateur.

\subsection{Règles}

Nous avons choisi d'implémenter un module destiné à l'application des règles tout au long de la partie. De manière plus spécifique, nous nous intéressons ici à la detection d'une situation incorrecte, d'une situation de terminaison ou bien du simple déroulement d'un coup joué.\newline

\begin{itemize}
\item Situation incorrecte \newline
La principale situation incorrecte dans notre système correspond au cas où un joueur tente d'ajouter un jeton dans une colonne déjà pleine. Le module en question contiendra les méthodes nécessaires à la detection de ce type de coup, méthodes que l'on utilisera alors pour avertir l'utilisateur de cette interdiction.\newline\newline

\item Situation de terminaison \newline
Une situation de terminaison se produit dans deux cas :\newline
Premièrement, un joueur aligne 4 pions dans la grille.\newline
Deuxièmement, la grille est remplie.\newline
De la même manière, on souhaitera que ces évènements soient détectés et traités en conséquence. C'est à dire, information de l'utilisateur et terminaison éventuelle du programme.\newline\newline


\item Déroulement d'un coup joué \newline
Lorsqu'un joueur communique son choix pour le coup en cours, le tableau d'entiers doit être modifié en conséquence. Nous avons décidé d'affecter cette tâche à ce module, qui sera donc en étroite corrélation avec la structure de données. Pour effectuer cette modification, la méthode correspondante aura connaissance du numéro du joueur en cours et la colonne choisie par ce joueur. L'action sera alors traduite par une affectation en accord avec les méthodes de la structure de données.\newline
\end{itemize}

L'ensemble de ces outils permettront au moteur de jeu décrit ci-dessous d'assurer le bon déroulement du jeu et donc du programme.
\paragraph{Tests d'intégration pour les règles}

\begin{itemize}
\bigskip
\item Situation incorrecte\newline
En intégrant nos règles dans le moteur de jeu, il est possible que le choix du joueur ne
soit pas dans l'intervalle de positions de la grille. Autrement dit,
le joueur va essayer de jouer à l'extérieur de la grille. C'est
pourquoi nous pensons entrer des tests aux limites de notre grille,
mais qui appellent sur toutes les possibilités nos règles. Nous
choisirons des données de tests négatives, nulles, de la taille de la
grille, et supérieur à la taille de la grille.
\bigskip
\item Situation plausible\newline
Il est certain qu'on va vérifier si notre moteur de jeu récupère bien
la valeur attendue et l'interprète correctement. Pour ce qui concerne
les données de tests de ce cas précis, nous pensons prendre une grille
6$\times$7 et effectuer les tests sur toutes les combinaisons
possibles pour vérifier si nos règles nous retournent le fait qu'un
joueur a remporté et la victoire.
\end{itemize}

\subsection{Moteur de jeu}

Le moteur de jeu sera le coeur de notre programme dans le sens où il mettra en rapport l'ensemble des entités du programme. Ainsi, il devra assurer le scénario standard suivant :

\begin{enumerate}
\item Phase d'initialisation
\item Phase de jeu (a)
\item Phase de modification (b)
\item Phase de communication (c)
\item Terminaison ou nouvelle partie
\end{enumerate}

La phase d'initialisation correspond à la création et au lancement de chacun des modules cités dans cette section: une grille de dimension choisie sera initialisée, les joueurs seront instanciés conformément au choix initial de l'utilisateur, l'interface utilisateur sera lancée au besoin, une instance du module de règles sera créée.\newline\newline

La phase de jeu correspond à l'ordonnancement des coups des joueurs. Tour à tour, le moteur de jeu consultera le joueur concerné et lui demandera de fournir le numéro de colonne qu'il souhaite jouer, qu'il soit humain ou ordinateur.\newline\newline

La phase de modification permettra de traduire ce choix en une consultation du module de règles et modification de la grille en conséquence.\newline\newline

La phase de communication représentera la notification au joueur via l'interface de la configuration actuelle du jeu. Ainsi, dans le cas d'une interface graphique on mettra à jour l'affichage du panneau en fonction du nouvel état de la grille.\newline\newline

Ces trois dernières phases (a-b-c) seront répétées jusqu'à ce qu'une situation de terminaison apparaîsse.\newline\newline

Enfin, l'utilisateur choisira de terminer le programme ou de jouer une nouvelle partie. Le module de jeu sera donc capable de se réinitialiser pour revenir à une configuration initiale.\newline\newline

Chacune de ces phases sera représentée par une ou des méthodes contenue dans une classe dédiée.\newline

\subsection{Composants annexes}

On trouvera d'autres classes d'importance mineure :\newline \newline 

Une classe main sera présente et permettra d'instancier le moteur de jeu au démarrage du programme en lui communiquant le choix de configuration de l'utilisateur. D'autres interfaces pourront être ajoutées pour augmenter la modularité du programme.\newline
Enfin, dans le cas d'une interface graphique, il sera nécessaire de représenter chaque position de la grille grâce à des éléments graphiques changeant de couleur. De la même manière, d'autres composants graphiques permetront à l'utilisateur de communiquer son choix quant au coup qu'il veut jouer. On trouvera également une zone graphique destinée à l'avertir de la terminaison de la partie.
