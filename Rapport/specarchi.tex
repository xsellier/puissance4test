\documentclass[12pt]{report}
\usepackage[latin1]{inputenc}
\usepackage[frenchb]{babel}

\begin{document}
\begin{titlepage}
\end{titlepage}

\clearpage

\tableofcontents

\chapter{Conception}
\section{Spécifications}
Le programme ici spécifié donne la possibilité à un utilisateur de jouer au jeu 'Puissance 4' dans les conditions décrites ci-dessous:

\subsection{Application des règles de puissance 4}

Règles concernant les joueurs:\newline
Le jeu se fait intervenir deux joueurs. Chaque joueur possède des jetons d'une couleur propre et ajoute lors de chaque tour un jeton dans une des colonnes d'une grille de dimensions n x m (par défaut 6 x 7). Un joueur est déclaré gagnant s'il aligne quatre jetons verticalement, horizontalement ou en diagonale dans la grille. Si la grille est remplie alors qu'aucun joueur n'a été déclaré gagnant, la partie est nulle.\newline\newline

Propriétés de la grille:\newline
Pour jouer à Puissance 4, on utilise comme support une grille dont les dimensions standard sont de 6 lignes et 7 colonnes, que l'on numérotera respectivement de 0 à 5 et de 0 à 6. Ce support doit être présent dans notre programme.\newline\newline

Déroulement de la partie:\newline
Au début de la partie, la grille est vide. Pendant la partie, des jetons de 2 couleurs différentes sont ajoutés successivement dans la grille jusqu'à ce qu'elle soit remplie ou que l'un des joueurs forme un alignement de 4 jetons de sa couleur. Un jeton est ajouté à la grille en fournissant le numéro de colonne. En effet, le numéro de ligne ne fait pas partie du choix du joueur dans le sens où un jeton descend nécessairement au niveau le plus bas accessible dans la grille. Par exemple, le premier jeton descend à la ligne numero 5 (la plus basse). Si une colonne est remplie (6 jetons on été insérés dans la même colonne), aucun joueur ne peut jouer de jeton dans cette colonne jusqu'à la fin de la partie.\newline\newline

On s'assurera que chacune de ces règles sera respectée dans notre programme.\newline

\subsection{Configurations de jeu et types de joueurs}

 Un joueur peut être un humain ou une entité controllée par l'ordinateur. Ainsi, on peut avoir les configurations de jeu suivantes: cpu vs joueur ou joueur vs joueur.
Quelle que soit la configuration, le programme contiendra une entité représentant le joueur 1 et le joueur 2. En fonction du mode choisi par l'utilisateur, le joueur 2 sera humain ou controllé par l'ordinateur. Le joueur 1 sera toujours humain. Un humain commence toujours la partie.\newline\newline

- IA : tous les deux tours la main est donnée à l'ordinateur. On veut pouvoir choisir différents niveaux de difficulté (i.e: l'ordinateur est plus ou moins performant selon le niveau choisi). Il doit être possible d'ajouter de nouveaux modes de difficulté facilement. Chaque niveau sera représenté par un algorithme qui déterminera le prochain coup que l'ordinateur va jouer (i.e le prochain numéro de colonne).\newline\newline

- humain : tous les deux tours la main est donnée à l'utilisateur. A chaque fois que le tour d'un humain vient, le programme attendra que l'utilisateur saisisse son choix.\newline\newline

Quelque soit le type de joueur, un choix de colonne doit être effectué à chaque tour de manière à ce que le programme s'exécute correctement. Dans le cas du joueur humain, on attendra que l'utilisateur fasse son choix grâce à une interaction avec l'interface (graphique ou dans le terminal).


\subsection{Visualisation}

 L'utilisateur du programme doit pouvoir visualiser en temps réel le déroulement du jeu, c'est-à-dire les coups joués par l'ordinateur ou l'humain. Dans un premier temps, on utilisera un affichage en mode console, puis si le planning le permet, une interface graphique plus agréable pour l'utilisateur. L'outil de visualisation doit être facilement interchangeable.\newline
En premier lieu, l'utilisateur doit pourvoir choisir, au travers de l'interface, quel type de configuration il souhaite utiliser et instancier une partie.\newline
Ensuite, lors du déroulement de la partie, il doit pouvoir connaître grâce à l'affichage quels sont les coups qui ont été joués jusqu'à l'instant où il lui est demandé de jouer. Enfin, il doit pouvoir interagir avec le panneau visuel de manière à faire connaître son choix pour le coup en cours au programme lorsque c'est à lui de jouer. Lorsqu'une partie est terminée, l'utilisateur doit être averti de l'issue de celle-ci (joueur 1 gagne, joueur 2 gagne ou match nul).
Eventuellement, il doit alors pouvoir jouer une nouvelle partie.\newline

\subsection{Tests associés}

a voir avec le groupe

\section{Architecture}
Nous allons décrire ici les différents modules imaginés pour répondre aux attentes formulées dans la partie spécification.\newline

\subsection{Structure de données}

Nous implémenterons une classe contenant un tableau d'entiers et les différentes méthodes nécessaires aux accès en écriture et lecture sur celui-ci. Ainsi, on doit pouvoir instancier un tableau de dimensions variables, initialiser ses valeurs et les modifier. Le tableau doit également pouvoir être réinitialisé. Cette classe a pour but de représenter la grille et donc les coups joués par chaque joueur au long de la partie. On représentera une case vide par un entier nul à la position correspondante. Un entier dont la valeur est à 1 représentera un coup joué par le joueur 1, même chose pour le joueur 2.\newline
C'est ce module qui va permettre au joueur ordinateur de connaître les possibilités de jeu à chaque tour (coups jouables). C'est grâce à cette représentation également que l'on saura si la partie est terminée ou non. Enfin, l'interface sera mise à jour à chaque tour en fonction de ce tableau, ce qui évitera des possibilités de confusion entre les deux entités.\newline

\subsection{Joueurs}

Il sera nécessaire d'implémenter 2 classes différentes pour les 2 types de joueurs. Cependant, certaines méthodes ou variables étant communes à ces entités on prévoiera une interface regroupant les méthodes nécessaires au jeu et appelées quelque soit le type de joueur. Ceci permettra au module en charge du déroulement du jeu de faire abstraction de la configuration choisie, et donc de diminuer le volume de code.

\subsubsection{Humain}

Le joueur humain aura une connexion étroite avec l'interface choisie. En effet, jouer un coup reviendra à interroger l'utilisateur via cette interface. Cette classe sera donc relativement peu volumineuse et d'une complexité faible.


\subsubsection{Ordinateur}

L'entité représentant le joueur artificiel sera plus importante. On devra pourvoir choisir entre 2 niveaux de difficultés, ce qui se traduira par une instanciation selon un paramètre particulier, comme un entier ou un boolén. Ainsi, la classe représentant ce type de joueur contiendra des méthodes différentes et correspondant chacune à ce niveau et donc paramètre choisi. On choisira premièrement un algorithme simple représentant une stratégie triviale (exemple: jouer la même colonne ou une colonne voisine de  celle choisie par le joueur 1 précédemment), puis on cherchera à implémenter un algorithme plus 'intelligent' permettant au joueur humain de se confronter à une difficulté de jeu élevée. On se rapprochera d'une stratégie gagnante pour le joueur-ordinateur.

\subsection{Règles}

Nous avons choisi d'implémenter un module destiné à l'application des règles tout au long de la partie. De manière plus spécifique, nous nous intéressons ici à la detection d'une situation incorrecte, d'une situation de terminaison ou bien du simple déroulement d'un coup joué.\newline

\begin{itemize}
\item Situation incorrecte \newline
La principale situation incorrecte dans notre système correspond au cas où un joueur tente d'ajouter un jeton dans une colonne déjà pleine. Le module en question contiendra les méthodes nécessaires à la detection de ce type de coup, méthodes que l'on utilisera alors pour avertir l'utilisateur de cette interdiction.\newline\newline

\item Situation de terminaison \newline
Une situation de terminaison se produit dans deux cas :\newline
Premièrement, un joueur aligne 4 pions dans la grille.\newline
Deuxièmement, la grille est remplie.\newline
De la même manière, on souhaitera que ces évènements soient détectés et traités en conséquence. C'est à dire, information de l'utilisateur et terminaison éventuelle du programme.\newline\newline


\item Déroulement d'un coup joué \newline
Lorsqu'un joueur communique son choix pour le coup en cours, le tableau d'entiers doit être modifié en conséquence. Nous avons décidé d'affecter cette tâche à ce module, qui sera donc en étroite corrélation avec la structure de données. Pour effectuer cette modification, la méthode correspondante aura connaissance du numéro du joueur en cours et la colonne choisie par ce joueur. L'action sera alors traduite par une affectation en accord avec les méthodes de la structure de données.\newline
\end{itemize}

L'ensemble de ces outils permettront au moteur de jeu décrit ci-dessous d'assurer le bon déroulement du jeu et donc du programme.


\subsection{Moteur de jeu}

Le moteur de jeu sera le coeur de notre programme dans le sens où il mettra en rapport l'ensemble des entités du programme. Ainsi, il devra assurer le scénario standard suivant :

\begin{enumerate}
\item Phase d'initialisation
\item Phase de jeu (a)
\item Phase de modification (b)
\item Phase de communication (c)
\item Terminaison ou nouvelle partie
\end{enumerate}

La phase d'initialisation correspond à la création et au lancement de chacun des modules cités dans cette section: une grille de dimension choisie sera initialisée, les joueurs seront instanciés conformément au choix initial de l'utilisateur, l'interface utilisateur sera lancée au besoin, une instance du module de règles sera créée.\newline\newline

La phase de jeu correspond à l'ordonnancement des coups des joueurs. Tour à tour, le moteur de jeu consultera le joueur concerné et lui demandera de fournir le numéro de colonne qu'il souhaite jouer, qu'il soit humain ou ordinateur.\newline\newline

La phase de modification permettra de traduire ce choix en une consultation du module de règles et modification de la grille en conséquence.\newline\newline

La phase de communication représentera la notification au joueur via l'interface de la configuration actuelle du jeu. Ainsi, dans le cas d'une interface graphique on mettra à jour l'affichage du panneau en fonction du nouvel état de la grille.\newline\newline

Ces trois dernières phases (a-b-c) seront répétées jusqu'à ce qu'une situation de terminaison apparaîsse.\newline\newline

Enfin, l'utilisateur choisira de terminer le programme ou de jouer une nouvelle partie. Le module de jeu sera donc capable de se réinitialiser pour revenir à une configuration initiale.\newline\newline

Chacune de ces phases sera représentée par une ou des méthodes contenue dans une classe dédiée.\newline

\subsection{Composants annexes}

On trouvera d'autres classes d'importance mineure :\newline \newline 

Une classe main sera présente et permettra d'instancier le moteur de jeu au démarrage du programme en lui communiquant le choix de configuration de l'utilisateur. D'autres interfaces pourront être ajoutées pour augmenter la modularité du programme.\newline
Enfin, dans le cas d'une interface graphique, il sera nécessaire de représenter chaque position de la grille grâce à des éléments graphiques changeant de couleur. De la même manière, d'autres composants graphiques permetront à l'utilisateur de communiquer son choix quant au coup qu'il veut jouer. On trouvera également une zone graphique destinée à l'avertir de la terminaison de la partie.





\end{document}
